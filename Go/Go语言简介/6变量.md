##### 匿名变量

在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。

匿名变量的特点是一个下画线“_”，“_”本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值**都将被抛弃**，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。例如：

```go
func GetData() (int, int) {
    return 100, 200
}
func main(){
    a, _ := GetData()
    _, b := GetData()
    fmt.Println(a, b)
}
```

代码运行结果：100 200

GetData() 是一个函数，拥有两个整型返回值。每次调用将会返回 100 和 200 两个数值。

代码说明如下：

- 第 5 行只需要获取第一个返回值，所以将第二个返回值的变量设为下画线（匿名变量）。
- 第 6 行将第一个返回值的变量设为匿名变量。

匿名变量**不占用内存空间，不会分配内存**。匿名变量与匿名变量之间也不会因为多次声明而无法使用。





HTTP 文件服务器是常见的 Web 服务之一。开发阶段为了测试，需要自行安装 Apache 或 Nginx 服务器，下载安装配置需要大量的时间。使用Go语言实现一个简单的 HTTP 服务器只需要几行代码，如下所示。

```go
package main

import (
    "net/http"
)

func main() {
    http.Handle("/", http.FileServer(http.Dir(".")))
    http.ListenAndServe(":8080", nil)
}
```

下面是代码说明：

- 第 1 行，标记当前文件为 main 包，main 包也是 Go 程序的入口包。
- 第 3~5 行，导入 net/http 包，这个包的作用是 HTTP 的基础封装和访问。
- 第 7 行，程序执行的入口函数 main()。
- 第 8 行，使用 http.FileServer 文件服务器将当前目录作为根目录（`/`目录）的处理器，访问根目录，就会进入当前目录。
- 第 9 行，默认的 HTTP 服务侦听在本机 8080 端口。



用 Printf 函数打印浮点数时可以使用“%f”来控制保留几位小数

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    fmt.Printf("%f\n", math.Pi)
    fmt.Printf("%.2f\n", math.Pi)
}
```

运行结果如下所示：

```
3.141593
3.14
```







Go语言是静态类型语言，因此变量（variable）是有明确类型的，编译器也会检查变量类型的正确性。在数学概念中，变量表示没有固定值且可改变的数。但从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。

声明变量的一般形式是使用 **var 关键字**：

```go
var name type
```



其中，var 是声明变量的关键字，name 是变量名，type 是变量的类型。

需要注意的是，Go语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。

这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：`int* a, b;` 。其中只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 Go 中，则可以和轻松地将它们都声明为指针类型：

```go
var a, b *int
```



Go语言的基本类型有：

- bool
- string
- int、int8、int16、int32、int64
- uint、uint8、uint16、uint32、uint64、uintptr
- byte // uint8 的别名
- rune // int32 的别名 代表一个 Unicode 码
- float32、float64
- complex64、complex128

当一个变量被声明之后，系统自动赋予它该类型的零值：

- int 为 0
- float 为 0.0
- bool 为 false
- string 为空字符串
- 切片、函数、指针变量的默认为 nil。

所有的内存在 Go 中都是经过初始化的。

变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。

变量的声明有几种形式，通过下面几节进行整理归纳。



##### 标准格式

Go语言的变量声明的标准格式为：

```go
var 变量名 变量类型
```



变量声明以关键字 var 开头，后置变量类型，行尾无须分号。



##### 批量格式

觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法：

```go
var (
    a int
    b string
    c []float32
    d func() bool
    e struct {
        x int
    }
)
```

使用关键字 var 和括号，可以将一组变量定义放在一起。



##### 简短格式

除 var 关键字外，还可使用更加简短的变量定义和初始化语法。

```
名字 := 表达式
```



需要注意的是，简短模式（short variable declaration）有以下限制：

- 定义变量，同时显式初始化。
- 不能提供数据类型。
- 只能用在函数内部。

和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：

```
i, j := 0, 1
```



下面通过一段代码来演示简短格式变量声明的基本样式。

```go
func main() {
   x:=100
   a,s:=1, "abc"
}
```

因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。







##### 变量初始化的标准格式

var 变量名 类型 = 表达式

例如，游戏中，玩家的血量初始值为100。可以这样写：

```go
var hp int = 100
```

这句代码中，hp 为变量名，类型为 int，hp 的初始值为 100。

上面代码中，100 和 int 同为 int 类型，int 可以认为是冗余信息，因此可以进一步简化初始化的写法。



##### 编译器推导类型的格式

在标准格式的基础上，将 int 省略后，编译器会尝试根据等号右边的表达式推导 hp 变量的类型。

```go
var hp = 100
```

等号右边的部分在编译原理里被称做右值（rvalue）。

下面是编译器根据右值推导变量类型完成初始化的例子。

```go
var attack = 40
var defence = 20
var damageRate float32 = 0.17
var damage = float32(attack-defence) * damageRate
fmt.Println(damage)
```

代码说明如下：

- 第 1 和 2 行，右值为整型，attack 和 defence 变量的类型为 int。

- 第 3 行，表达式的右值中使用了 0.17。由于Go语言和C语言一样，编译器会尽量提高精确度，以避免计算中的精度损失。所以这里如果不指定 damageRate 变量的类型，Go语言编译器会将 damageRate 类型推导为 float64，我们这里不需要 float64 的精度，所以需要强制指定类型为 float32。

- 第 4 行，将 attack 和 defence 相减后的数值结果依然为整型，使用 float32() 将结果转换为 float32 类型，再与 float32 类型的 damageRate 相乘后，damage 类型也是 float32 类型。

  > 提示：damage 变量的右值是一个复杂的表达式，整个过程既有 attack 和 defence 的运算还有强制类型转换。强制类型转换会在后面的章节中介绍。

- 第 5 行，输出 damage 的值。

以上代码输出结果为：3.4





##### 短变量声明并初始化

var 的变量声明还有一种更为精简的写法，例如：

```
hp := 100
```

这是Go语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。

> 注意：由于使用了`:=`，而不是赋值的`=`，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。

如果 hp 已经被声明过，但依然使用`:=`时编译器会报错，代码如下：

```
// 声明 hp 变量var hp int// 再次声明并赋值hp := 10
```

编译报错如下：

no new variables on left side of :=

意思是，在“:=”的左边没有新变量出现，意思就是“:=”的左边变量已经被声明了。

短变量声明的形式在开发中的例子较多，比如：

```
conn, err := net.Dial("tcp","127.0.0.1:8080")
```

net.Dial 提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象（conn），一个是错误对象（err）。如果是标准格式将会变成：

```
var conn net.Connvar err errorconn, err = net.Dial("tcp", "127.0.0.1:8080")
```

因此，短变量声明并初始化的格式在开发中使用比较普遍。

注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：

```
conn, err := net.Dial("tcp", "127.0.0.1:8080")conn2, err := net.Dial("tcp", "127.0.0.1:8080")
```

上面的代码片段，编译器不会报 err 重复定义。



##### 交换变量

```go
package main

import "fmt"

func main() {
	a, b := 100, 200
	b, a = a, b
	fmt.Println(a, b)
}
```







##### 作用域

了解变量的作用域对我们学习Go语言来说是比较重要的，因为Go语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。

根据变量定义位置的不同，可以分为以下三个类型：

- 函数内定义的变量称为局部变量
- 函数外定义的变量称为全局变量
- 函数定义中的变量称为形式参数





##### 局部变量

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。

局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。

【示例】下面的 main() 函数中使用到了局部变量 a、b、c。

```go
package main

import (
    "fmt"
)

func main() {
    //声明局部变量 a 和 b 并赋值
    var a int = 3
    var b int = 4
    //声明局部变量 c 并计算 a 和 b 的和
    c := a + b
    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
```

运行结果如下所示：a = 3, b = 4, c = 7



##### 全局变量

在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。

全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。

【示例】下面代码中，第 6 行定义了全局变量 c。

```go
package main

import "fmt"

//声明全局变量
var c int

func main() {
    //声明局部变量
    var a, b int

    //初始化参数
    a = 3
    b = 4
    c = a + b

    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
```

运行结果如下所示：a = 3, b = 4, c = 7



Go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。

```go
package main

import "fmt"

//声明全局变量
var a float32 = 3.14

func main() {
    //声明局部变量
    var a int = 3

    fmt.Printf("a = %d\n", a)
}
```

运行结果如下所示：a = 3





##### 形式参数

在定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁；

在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。

形式参数会作为**函数的局部变量**来使用。

【示例】下面代码中第 21 行定义了形式参数 a 和 b。

```go
package main

import (
    "fmt"
)

//全局变量 a
var a int = 13

func main() {
    //局部变量 a 和 b
    var a int = 3
    var b int = 4

    fmt.Printf("main() 函数中 a = %d\n", a)
    fmt.Printf("main() 函数中 b = %d\n", b)
    c := sum(a, b)
    fmt.Printf("main() 函数中 c = %d\n", c)
}

func sum(a, b int) int {
    fmt.Printf("sum() 函数中 a = %d\n", a)
    fmt.Printf("sum() 函数中 b = %d\n", b)
    num := a + b
    return num
}
```

运行结果如下所示：

```
main() 函数中 a = 3
main() 函数中 b = 4
sum() 函数中 a = 3
sum() 函数中 b = 4
main() 函数中 c = 7
```

