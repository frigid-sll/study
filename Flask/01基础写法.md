为了测试 **Flask** 安装，请在编辑器中将以下代码输入 **Hello.py：**

```python3
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
   return 'Hello World'

if __name__ == '__main__':
   app.run()
```

必须在项目中导入Flask模块。 

Flask类的一个对象是我们的**WSGI**应用程序。

Flask构造函数使用**当前模块（__name __）**的名称作为参数。

Flask类的**route()**函数是一个装饰器，它告诉应用程序哪个URL应该调用相关的函数。

```
app.route(rule, options)
```

- **rule** 参数表示与该函数的URL绑定。
- **options** 是要转发给基础Rule对象的参数列表。

在上面的示例中，'/ ' URL与**hello_world()**函数绑定。

因此，当在浏览器中打开web服务器的主页时，将呈现该函数的输出。

最后，Flask类的**run()**方法在本地开发服务器上运行应用程序。

```
app.run(host, port, debug, options)
```

所有参数都是可选的

| 序号 | 参数与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **host** 要监听的主机名。 默认为127.0.0.1（localhost）。设置为“0.0.0.0”以使服务器在外部可用 |
| 2    | **port** 默认值为5000                                        |
| 3    | **debug** 默认为false。 如果设置为true，则提供调试信息       |
| 4    | **options** 要转发到底层的Werkzeug服务器。                   |

上面给出的**Python**脚本是从Python shell执行的。

```
python Hello.py
```

Python shell中的消息通知您：

```
* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
```

在浏览器中打开上述URL**（localhost：5000）**。将显示**“Hello World”**消息。





#### Flask URL构建

2023-03-24 09:32 更新

**url_for()**函数对于动态构建特定函数的URL非常有用。

**url_for()**函数接受函数的名称作为第一个参数，以及一个或多个关键字参数，每个参数对应于URL的变量部分。

以下脚本演示了如何使用**url_for()**函数：

```python3
from flask import Flask, redirect, url_for
app = Flask(__name__)
@app.route('/admin')
def hello_admin():
   return 'Hello Admin'


@app.route('/guest/<guest>')
def hello_guest(guest):
   return 'Hello %s as Guest' % guest


@app.route('/user/<name>')
def hello_user(name):
   if name =='admin':
      return redirect(url_for('hello_admin'))
   else:
      return redirect(url_for('hello_guest', guest=name))
   
if __name__ == '__main__':
   app.run(host='0.0.0.0', port=888)
```

上述脚本有一个函数**hello_user****(name)**，它接受来自URL的参数的值。

**hello_user****()**函数检查接收的参数是否与**'admin'**匹配。

如果匹配，则使用**url_for()**将应用程序重定向到**hello_admin()**函数，否则重定向到将接收的参数作为guest参数传递给它的**hello_guest()**函数。

保存上面的代码并从Python shell运行。

打开浏览器并输入URL - **http://localhost:888/user/admin**

浏览器中的应用程序响应是：

```
Hello Admin
```

在浏览器中输入以下URL - **http://localhost:888/user/mvl**

应用程序响应现在更改为：

```
Hello mvl as Guest
```



#### Flask HTTP方法

2022-08-16 10:38 更新

Http协议是万维网中数据通信的基础。在该协议中定义了从指定URL检索数据的不同方法。

下表总结了不同的http方法：

| 序号 | 方法与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **GET**以未加密的形式将数据发送到服务器。最常见的方法。      |
| 2    | **HEAD**和GET方法相同，但没有响应体。                        |
| 3    | **POST**用于将HTML表单数据发送到服务器。POST方法接收的数据不由服务器缓存。 |
| 4    | **PUT**用上传的内容替换目标资源的所有当前表示。              |
| 5    | **DELETE** 删除由URL给出的目标资源的所有当前表示。           |

默认情况下，Flask路由响应**GET**请求。但是，可以通过为**route()**装饰器提供方法参数来更改此首选项。

为了演示在URL路由中使用**POST**方法，首先让我们创建一个HTML表单，并使用**POST**方法将表单数据发送到URL。

将以下脚本另存为login.html

```html
<html>
   <body>
      <form action = "http://localhost:5000/login" method = "post">
         <p>Enter Name:</p>
         <p><input type = "text" name = "nm" /></p>
         <p><input type = "submit" value = "submit" /></p>
      </form>
   </body>
</html>
```

现在在Python shell中输入以下脚本：

```python3
from flask import Flask, redirect, url_for, request, render_template

app = Flask(__name__)

@app.route('/')
def index():
    return render_template("login.html")

@app.route('/success/<name>')
def success(name):
    return 'welcome %s' % name

@app.route('/login',methods = ['POST', 'GET'])
def login():
   if request.method == 'POST':
      print(1)
      user = request.form['nm']
      return redirect(url_for('success', name=user))
   else:
      print(2)
      user = request.args.get('nm')
      if not user:
         user = 'sll'
      return redirect(url_for('success', name=user))

if __name__ == '__main__':
   app.run(host='0.0.0.0', port=888)
```

开发服务器开始运行后，在浏览器中打开**login.html**，在文本字段中输入name，然后单击**提交**。

表单数据将POST到表单标签的action子句中的URL。

**http://localhost:888/login**映射到**login()**函数。由于服务器通过**POST**方法接收数据，因此通过以下步骤获得从表单数据获得的“nm”参数的值：

```html
user = request.form['nm']
```

它作为变量部分传递给**'/success'** URL。浏览器在窗口中显示**welcome** 消息。

在**login.html**中将方法参数更改为**'GET'**，然后在浏览器中再次打开它。服务器上接收的数据是通过**GET**方法获得的。通过以下的步骤获得'nm'参数的值：

http://localhost:888/login?nm=www

```html
User = request.args.get('nm')
```

这里，**args**是包含表单参数对及其对应值对的列表的字典对象。与'nm'参数对应的值将像之前一样传递到'/ success' URL。





#### Flask 静态文件

2022-08-16 10:38 更新

Web应用程序通常需要静态文件，例如**javascript**文件或支持网页显示的**CSS**文件。

通常，配置Web服务器并为您提供这些服务，但在开发过程中，这些文件是从您的包或模块旁边的*static*文件夹中提供，它将在应用程序的**/static**中提供。

特殊端点'static'用于生成静态文件的URL。

在下面的示例中，在**index.html**中的HTML按钮的**OnClick**事件上调用**hello.js**中定义的**javascript**函数，该函数在Flask应用程序的**“/”**URL上呈现。

```python3
from flask import Flask, render_template
app = Flask(__name__)

@app.route("/")
def index():
   return render_template("index.html")

if __name__ == '__main__':
   app.run(debug = True)
```

**index.html**的HTML脚本如下所示：

```html
<html>

   <head>
      <script type = "text/javascript" 
         src = "{{ url_for('static', filename = 'hello.js') }}" ></script>
   </head>
   
   <body>
      <input type = "button" onclick = "sayHello()" value = "Say Hello" />
   </body>
   
</html>
```

**
**

**在static文件夹中的hello.js**包含**sayHello()**函数。

```javascript
function sayHello() {
   alert("Hello World")
}
```





#### Flask Request对象

2019-01-09 16:08 更新

来自客户端网页的数据作为全局请求对象发送到服务器。为了处理请求数据，应该从Flask模块导入。

Request对象的重要属性如下所列：

- **Form** - 它是一个字典对象，包含表单参数及其值的键和值对。
- **args** - 解析查询字符串的内容，它是问号（？）之后的URL的一部分。
- **Cookies** - 保存Cookie名称和值的字典对象。
- **files** - 与上传文件有关的数据。
- **method** - 当前请求方法。





#### Flask 将表单数据发送到模板

2022-08-16 10:38 更新

我们已经看到，可以在 URL 规则中指定 http 方法。触发函数接收的 **Form** 数据可以以字典对象的形式收集它并将其转发到模板以在相应的网页上呈现它。

在以下示例中，**'/' URL** 会呈现具有表单的网页（student.html）。

填入的数据会发布到触发 **result()** 函数的 **'/result' URL**。

**result()** 函数收集字典对象中的 **request.form** 中存在的表单数据，并将其发送给 **result.html**。

该模板动态呈现**表单**数据的 HTML 表格。

下面给出的是应用程序的 Python 代码：

```python3
from flask import Flask, render_template, request
app = Flask(__name__)
@app.route('/')
def student():
   return render_template('student.html')
@app.route('/result',methods = ['POST', 'GET'])
def result():
   if request.method == 'POST':
      result = request.form
      return render_template("result.html",result = result)
if __name__ == '__main__':
   app.run(debug = True)
```

下面给出的是 **student.html** 的 HTML 脚本。

```html
<form action="http://localhost:5000/result" method="POST">
     <p>Name <input type = "text" name = "Name" /></p>
     <p>Physics <input type = "text" name = "Physics" /></p>
     <p>Chemistry <input type = "text" name = "chemistry" /></p>
     <p>Maths <input type ="text" name = "Mathematics" /></p>
     <p><input type = "submit" value = "submit" /></p>
</form>
```

下面给出了模板**（ result.html ）**的代码：

```html
<!doctype html>
  <table border = 1>
     {% for key, value in result.items() %}
    <tr>
       <th> {{ key }} </th>
       <td> {{ value }}</td>
    </tr>
 {% endfor %}
</table>
```

运行 Python 脚本，并在浏览器中输入 URL **http://localhost:5000/**。

![Submit Marks](https://atts.w3cschool.cn/attachments/tuploads/flask/submit_marks.jpg)

当点击**提交**按钮时，表单数据以 HTML 表格的形式呈现在 **result.html** 上。

![Marks Table](https://atts.w3cschool.cn/attachments/tuploads/flask/marks_table.jpg)







##### Flask 重定向和错误

2022-08-16 10:43 更新

Flask类有一个**redirect()**函数。调用时，它返回一个响应对象，并将用户重定向到具有指定状态代码的另一个目标位置。

**redirect()**函数的原型如下：

```
Flask.redirect(location, statuscode, response)
```

在上述函数中：

- **location**参数是应该重定向响应的URL。
- **statuscode**发送到浏览器标头，默认为302。
- **response**参数用于实例化响应。

以下状态代码已标准化：

- HTTP_300_MULTIPLE_CHOICES
- HTTP_301_MOVED_PERMANENTLY
- HTTP_302_FOUND
- HTTP_303_SEE_OTHER
- HTTP_304_NOT_MODIFIED
- HTTP_305_USE_PROXY
- HTTP_306_RESERVED
- HTTP_307_TEMPORARY_REDIRECT

**默认状态**代码为**302**，表示**'found'**。

在以下示例中，**redirect()**函数用于在登录尝试失败时再次显示登录页面。

```python3
from flask import Flask, redirect, url_for, render_template, request
# Initialize the Flask application
app = Flask(__name__)

@app.route('/')
def index():
    return render_template('log_in.html')

@app.route('/login', methods=['POST', 'GET'])
def login():
    if request.method == 'POST' and request.form['username'] == 'admin':
        return redirect(url_for('success'))
    return redirect(url_for('index'))

@app.route('/success')
def success():
    return 'logged in successfully'

if __name__ == '__main__':
    app.run(debug=True)
```

Flask类具有带有错误代码的**abort()**函数。

```
Flask.abort(code)
```

**Code** 参数采用以下值之一：

- **400** - 用于错误请求
- **401** - 用于未身份验证的
- **403** - Forbidden
- **404** - 未找到
- **406** - 表示不接受
- **415** - 用于不支持的媒体类型
- **429** - 请求过多

让我们对上述代码中的**login()**函数稍作更改。如果要显示**'Unauthurized'**页面，请将其替换为调用**abort(401)**，而不是重新显示登录页面。

```python3
from flask import Flask, redirect, url_for, render_template, request, abort
app = Flask(__name__)

@app.route('/')
def index():
   return render_template('log_in.html')

@app.route('/login',methods = ['POST', 'GET'])
def login():
   if request.method == 'POST':
      if request.form['username'] == 'admin' :
         return redirect(url_for('success'))
      else:
         abort(401)
   else:
      return redirect(url_for('index'))

@app.route('/success')
def success():
   return 'logged in successfully'

if __name__ == '__main__':
   app.run(debug = True)
```