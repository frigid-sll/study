

##### 向用户抛出错误

我们会对前面小节中的change_state方法作出修改，并对用户尝试修改is_allowed_transition所不允许的状态时显示帮助信息。按照如下步骤来进行操作：

- 在该Python文件的开头添加如下导入语句：

  ```python
  from odoo.exceptions import UserError
  from odoo.tools.translate import _
  ```

- 修改change_state方法并在else部分中抛出UserError异常

  ```python
  @api.multi
  def change_state(self, new_state):
      for book in self:
          if book.is_allowed_transition(book.state, new_state):
              book.state = new_state
          else:
              msg = _('Moving from %s to %s is not allowed') % (book.state, new_state)
              raise UserError(msg)
  ```



##### 运行原理

Python 中抛出异常时，它会延着调用栈进行传递直到被处理为止。在Odoo中，响应网页客户端发出调用的RPC(远程过程调用)层会捕获所有异常，根据异常类的不同来触发网页客户端上的不同行为。

odoo.exceptions中所未定义的异常通过栈追踪按内部服务器错误（HTTP状态码500）来处理。UserError 会在用户界面中显示错误信息。本节中抛出UserError错误的代码用于确保错误消息以用户友好的方式显示。在所有的用例中，当前数据库事务会被回滚。

我使用了一个名称很奇怪的函数，_()，它在odoo.tools.translate中定义。这个函数用于标记字符串为可翻译，并在运行时根据在执行上下文中查找到的终端用户语言获取翻译字符串。更多详情请参见[第十一章 国际化](https://alanhou.org/odoo-14-internationalization/)。

> **📝重要贴士：**在使用 _()函数时，确保你仅传递带有插值占位符的字符串，而非整个插值字符串。比如，_(‘Warning: could not find %s’) % value是正确的，_(‘Warning: could not find %s’ % value) 就是错误的，因为第一个字符串不会在翻译数据库中找到替换值。



##### 扩展知识…

有时，会用到有错误倾向的代码，表示你所执行的操作可能会产生错误。Odoo会捕获这一错误并对用户显示回溯。

如果你不想要向用户显示完整错误日志，可以缓存错误并抛出一个更具含义的自定义异常。

在给出的示例中，我们在try…cache代码块中生成了UserError错误来代替显示完整错误日志。现在Odoo会显示有明确含义的警告：

```python
def post_to_webservice(self, data):
     try:
         req = requests.post('http://my-test-service.com', data=data, timeout=10)
         content = req.json()
     except IOError:
        error_msg = _("Something went wrong during data submission")
        raise UserError(error_msg)
    return content
```

在odoo.exceptions中定义了更多的异常类，都从基本的原有except_orm异常类进行派生。它们大多数仅在内部使用，除以下几种：

- ValidationError：这个异常在没有满足Python对字段的约束时抛出。参见[第四章 应用模型](https://alanhou.org/odoo-14-application-models/)中*向模型添加约束验证*一节获取更多信息。
- AccessError：这个错误通常在用户尝试访问未经允许的内容时会自动生成。如果想要显示访问错误可在代码中手动报出错误。
- RedirectWarning：使用这个错误，可以对错误消息显示重定向按钮。需要对这一异常传递两个参数：第一个是动作 ID，第二个参数是错误消息。
- Warning：在Odoo 8.0中，odoo.exceptions.Warning起着和9.0及之后版本中UserError相同的作用。现在它被弃用的原因是名称具有欺骗性（它是一个错误，而非警告），并且它与Python内置的Warning类有冲突。仅为向后兼容进行了保留，应当在代码中使用UserError。



##### 获取其它模型的空记录集

- 在LibraryBook类中，编写一个名为get_all_library_members的方法

  ```python
  class NewLibraryBook(models.Model):
      _name = 'new.library.book'
      ###
      def log_all_library_members(self):
              '''获取library.book方法中获取library.book.member的记录集'''
              library_member_model = self.env['library.book.member'] # 这是library.member的空记录集
              all_members = library_member_model.search([])
              print('ALL MEMBERS:', all_members)
              raise UserError(all_members)
  ```

- 在`<form>`视图中添加一个按钮调用该方法：

  ```xml
  <button name="log_all_library_members" string="Log Members" type="object"/>
  ```

- 更新模块来应用以上修改。之后就会在书的`<form>`视图中看到Log Members按钮。点击该按钮，会看到会员的记录集。



##### 运行原理…

在启动时，Odoo加载了所有的模块并合并从Model中所获取的不同类，同时也定义或继承了给定的模型。这些类存储在Odoo仓库中，按名称索引。任意记录集中的env属性，可通过self.env访问，都是定义在odoo.api模块中的Environment类的实例。

这个类在Odoo开发中扮演着中心角色：

- 它通过模拟Python字典来提供对仓库的快速访问。如果你知道所要查找的模型名，self.env[model_name]会获取该模型的空记录集。再者，该记录集会共享self的环境。
- 它有一个cr属性，是可以用于传递原生SQL查询的数据库游标。参见[第八章 高级服务端开发技巧](https://alanhou.org/odoo-14-advanced-server-side-development-techniques/)中的*执行原生SQL查询*一节获取更多信息。
- 它有一个user属性，是对执行调用的当前用户的引用。参见[第八章 高级服务端开发技巧](https://alanhou.org/odoo-14-advanced-server-side-development-techniques/)中的*更改执行动作的用户*一节获取更多信息。
- 它有一个context属性，是一个包含调用上下文的字典。这包含用户语言、时区、当前记录选项等等的信息。参见[第八章 高级服务端开发技巧](https://alanhou.org/odoo-14-advanced-server-side-development-techniques/)中的*使用变更的上下文调用方法*一节获取更多信息。

search()的调用在稍后的*搜索记录*一节中进行讲解。



##### 新建记录

- 在library.book.category中创建一个名为create_categories的方法：

  ```python
  @api.constrains('parent_id')
  def _check_hierarchy(self):
      if not self._check_recursion():
          raise models.ValidationError('Error! You cannot create recursive categories.')
  
  def create_categories(self):
    	#准备一个包含第一个子类各字段值的字典
      categ1 = {
          'name': 'Child category 1',
          'description': 'Description for child 1'
      }
      #准备包含第二个子类各字段值的字典
      categ2 = {
          'name': 'Child category 2',
          'description': 'Description for child 2'
      }
      #准备包含父类各字段值的字典
      parent_category_val = {
          'name': 'Parent category',
          'description': 'Description for parent category',
          'child_ids': [
              (0, 0, categ1),
              (0, 0, categ2),
          ]
      }
      #调用create()方法来新建记录
      record = self.env['library.book.category'].create(parent_category_val)
  ```

- 在`<form>`视图中添加用户界面中触发create_categories方法的按钮：

  ```
  <button name="create_categories" string="Create Categories" type="object"/>
  ```

- 点击后就可以创建categ1、categ2、parent_category_val三个新分类，并且categ1和categ2是parent_categories的子类



##### 运行原理…

要为模型新建记录，我们可以对任意与模型关联的记录集调用create(values)方法。该方法返回一个长度为1的新记录集，其中包含带有值字典中所指定字段值的这条新记录。

在字典中，各个键给定字段的名称，相应的值与字段值对应。根据字段类型的不同，需要对值传递不同的Python类型：

- Text字段值给定的类型为Python字符串。

- Float和Integer字段值使用Python的浮点型和整型。

- Boolean字段值最好使用Python布尔类型或整型。

- Date字段值使用Python的datetime.date 对象。

- Datetime字段值使用Python的datetime.datetime对象。

- Binary字段值以Base64编码字符串进行传递。Python标准库中的base64模块提供诸如encodebytes(bytestring)的方法来对字符串以Base64进行编码。

- Many2one字段值给定的为整型，应为关联记录的数据库ID。

- One2many和Many2many字段使用一个特殊语法。值为包含三个元素元组的一个列表，如下：

  | 元组             | 效果                                                         |
  | :--------------- | :----------------------------------------------------------- |
  | (0, 0, dict_val) | 创建一条与主记录关联的新记录。                               |
  | (6, 0, id_list)  | 在所创建记录与已有记录间创建一个关联，它们的 ID 在一个名为 id_list 的 Python 列表中。 注意：在用于 One2many 字段时，这会删除此前关联中的记录。 |

在本节中，我们在所要创建的公司中新建了两个联系人的字典，然后我们使用通过前述(0, 0, dict_val)语法所创建公司字典child_ids键中的这些字典。

在第5步中调用create()时，创建了三条记录：

- 一条是父级图书分类，由create返回
- 两条为子级图书分类，可通过record.child_ids进行获取



##### 扩展知识…

如果该模型为某些字段定义了一些默认值，不需要做什么特别的事情，create()会处理所提供字典中不存在字段默认值的计算。

从Odoo 12开始，create()方法还支持批量创建记录。要批量创建多条记录，需要向create() 方法传递一个多值列表，如下例所示：

```python
categ1 = {
  'name': 'Category 1',
  'description': 'Description for Category 1'
}
categ2 = {
  'name': 'Category 2',
  'description': 'Description for Category 2'
}
multiple_records = self.env['library.book.category'].create([categ1, categ2])
```

