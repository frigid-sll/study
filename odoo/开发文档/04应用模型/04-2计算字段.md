##### 向模型添加计算字段

有时，我们的字段需要通过计算获取值或从相同记录或关联记录中的值获取值。一个典型的示例是总价，由单价乘以数量计算所得。在Odoo模型中，可使用计算字段来实现。

为展示如何使用示计算字段，我们将向图书模型中添加一个字段来计算图书的发行天数。

也可以让计算字段可编辑和可搜索。我们会在示例中进行实现。

我们将编辑models/library_book.py代码文件来新增一个字段及支持它的逻辑的方法：

- 首先向图书模型添加一个新字段

  ```python
  class LibraryBook(models.Model):
       # ...
       age_days = fields.Float(
           string='Days Since Release',
           compute='_compute_age',
           inverse='_inverse_age',
           search='_search_age',
           store=False, # optional
           compute_sudo=False # optional
       )
  ```

- 然后，添加计算逻辑的方法

  ```python
  # ...
  from odoo import api # if not already imported
  # ...
  class LibraryBook(models.Model):
      # ...
      @api.depends('date_release')
      def _compute_age(self):
          today = fields.Date.today()
          for book in self:
              if book.date_release:
                  delta = today - book.date_release
                  book.age_days = delta.days
              else:
                  book.age_days = 0
  ```

- 要添加方法及实现写入计算字段的逻辑，使用如下代码：

  ```python
  from datetime import timedelta
  # ...
  class LibraryBook(models.Model):
      # ...
      def _inverse_age(self):
          today = fields.Date.today()
          for book in self.filtered('date_release'):
              d = today - timedelta(days=book.age_days)
              book.date_release = d
  ```

- 使用如下代码实现允许在计算字段中进行搜索的逻辑

  ```python
  from datetime import timedelta
  class LibraryBook(models.Model):
      # ...
      def _search_age(self, operator, value):
          today = fields.Date.today()
          value_days = timedelta(days=value)
          value_date = today - value_days
          # 运算符转换：
          # age_days > value -> date < value_date
          operator_map = {
              '>': '<', '>=': '<=',
              '<': '>', '<=': '>=',
          }
          new_op = operator_map.get(operator, operator)
          return [('date_release', new_op, value_date)]
  ```

- 需升级模块并重启Odoo来正确地启用这些新条件。



##### 计算字段，提供由函数计算出值的属性。

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| compute      | 计算字段的方法的名称                                         |
| inverse      | 反转字段的方法，并写入（可选）                               |
| search       | 在字段上实现搜索的方法的名称（可选）                         |
| store        | 字段是否存储在数据库中（布尔值，默认情况下在计算字段上为False） |
| compute_sudo | 是否应将该字段重新计算为超级用户以绕过访问权限（布尔值，默认为False） |
| related      | 通过关联模型的字段可在模型中直接可用，并且可通过点号标记法直接访问 |



##### 运行原理…

计算字段的定义和普通字段一致，不同的是添加了一个compute属性来指定用于计算的方法名。

它们的相似性带有欺骗性，因为计算字段的内部与普通字段有非常大的不同。计算字段是在运行时动态计算的，**因此不在数据库中存储**、默认无法对计算字段进行写操作。你需要自己对计算字段添加可写、可搜索的支持。下面看如何实现。

计算函数在运行时动态计算，但ORM使用缓存来避免在每次访问值时的低效重计算。因此，它需要知道所依赖的其它字段。它使用@depends装饰器来监测缓存值何时应置为无效并重新计算。

> ℹ️确保compute函数总是为计算字段设置一个值。否则会抛出错误。这在代码中包含if条件而对计算字段设置值失败时会发生。那样会很难进行调试。

**写操作可通过实现inverse函数来添加**。使用分配给计算字段的值来更新原字段。当然，这只在较简单的计算中有意义，但还是有些用例可以用到它的。在我们的示例中， 我们让通过编辑Days Since Release计算字段来设置图书发行日期成为可能。inverse是可选属性，如果不想让该计算字段可编辑，可以忽略它。

也可以通过将search属性设置为方法名（类似compute和inverse）来让非存储的计算字段可搜索。类似inverse，search也是可选属性，如果不想让该计算字段可搜索，可以忽略它。

但是，这个方法预期不实现实际的搜索。而是接收用于搜索该字段的运算符和值来作为参数，并应返回一个带有用于替换搜索条件的域。本例中，我们将一个发行天数字段的搜索转换为发行日期字段上等价的搜索条件。

可选的**store=True**标记存储数据库中的字段。在这种情况下，执行计算后字段值会存储到数据库中，此后它们会像普通字段一样进行获取，而不是运行时重新计算。借助@api.depends装饰器，ORM会知道何时需要重新计算并更新这些存储值。你可以把它看作一个持久缓存。它还具有可将该字段作为搜索条件的好处，包括排序和分组的操作。

如果在计算字段中使用store=True，则无需实再现search方法，因为字段已存储在数据库中，可以直接根据存储字段搜索、排序。

compute_sudo=True标记用于需要提权来执行计算的情况。这种情况可能是计算时需要使用终端用户无法访问的数据。

> 📝重要小记：Odoo v13中compute_sudo的默认值发生了改变。在Odoo v13之前，compute_sudo的值为False。但在v13中，compute_sudo的默认值基于store属性。如果store属性为True，则compute_sudo为True，否则为False。但是开发者可以在字段定义放置compute_sudo来显式地手动进行修改。
>
> 使用它时需要小心，因为它会跳过权限规则 ，包含多公司设置的按公司分隔的规则。确保反复确认在计算中所使用的域来避免相关的问题。



##### 扩展知识…

Odoo v13对ORM引入了一种新型的缓存机制。此前，根据环境进行缓存，但在Odoo v13中使用了全局缓存。因而，如果存在依赖于上下文值的计算字段，那么有时可能会得到错误的值。可以使用@api.depends_context装饰器解决这一问题。参见如下示例：

```python
@api.depends('price')
@api.depends_context('company_id')
def _compute_value(self):
    company_id = self.env.context.get('company_id')
    ...
    # other computation
```

前例中可以看到运算中使用了上下文中的company_id。通过在depends_context装饰器中使用company_id，我们可以确保字段值会根据上下文中company_id的值重新进行计算。
