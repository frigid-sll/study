##### 使用继承向模型添加功能

Odoo一个最重要的功能是模块插件可以继承其它模块插件中定义的功能，而又无需编辑原功能中的代码。可以是添加字段或方法，修改已有字段或继承已有方法来执行额外的逻辑。

根据官方文档所说，Odoo提供三种类型的继承：

- 类继承（扩展）：
  - 修改继承表的结构
  - 添加字段等
  - 不会新建子表

- 原型继承：
  - 会新建子表，继承所有字段
  - 父表或子表进行增加或修改数据互不影响
  - 但父表修改字段名，这个子表也会修改字段名
  - 可以新增父表中没有的新字段

- 代理继承：
  - 会新建子表，只继承某些字段
    - 在使用继承的字段的时候可以选择父表中这个字段已有的值，也可以新建父表中没有的值
    - 在新的子表中创建数据，如果继承字段的值在父表中没有，那么父表也会新建一个这个字段的数据。

  - 可以新增父表中没有的新字段
- 抽象继承：
  - 多个模型拥有同一个字段
  - 该字段可以实现某个功能
  - 不同模型之间的同一个字段内容互不影响




我们会通过不同的小节学习这些继承。本节中我们学习类型继承（扩展）。用于对已有模型添加新字段或方法。

我们将继承内置的客户模型res.partner来添加所著书数量的计算字段。包含对已有模型添加一个字段或一个方法。





##### 类继承（扩展）

我们将继承内置的Partner模型。读者可能还记得我们在本章的*向模型添加关联字段*一节中继承过res.partner。为了简化讲解，我们将复用 models/library_book.py代码文件中的res.partner模型：

- 首先，我们将确保在Partner模型中有authored_book_ids反向关联并添加计算字段：

  ```python
  class ResPartner(models.Model):
       _inherit = 'res.partner'
       _order = 'name'
       authored_book_ids = fields.Many2many(
          'library.book', string='Authored Books')
       count_books = fields.Integer( 'Number of Authored Books',
          compute='_compute_count_books' )
  ```

- 然后，添加需要用于计算图书数量的方法

  ```python
  # ...
  from odoo import api # if not already imported
  # class ResPartner(models.Model):
       # ...
       @api.depends('authored_book_ids')
       def _compute_count_books(self):
           for r in self:
              r.count_books = len(r.authored_book_ids)
  ```

- 最后，我们需要升级这个插件模块来让修改生效。



##### 运行原理…

在模型类通过_inherit属性进行定义时，它向所继承模型添加了修改，而没有进行替换。

这意味着在继承类中定义的字段会在父级模型中新增或修改。在数据库层，ORM对同一张数据表添加字段。

字段也被增量修改。表示如果该字段在父类中已存在，仅修改在继承类中声明的属性，其它的保持原有父类中的内容不变。

在继承类中定义的方法替换父类中的方法。如果你不通过super调用触发父级方法，那么父级版本的方法则不会被调用，我们也就不拥有该项功能。因此，通过继承在已有方法中添加新逻辑时，应包含一个带有super的语句来调用其父类中的方法。这部分在[第五章 基本服务端开发](https://alanhou.org/odoo-14-basic-server-side-development/)中做进一步的讲解。

> 📝本节会向已有模型新增字段。如果想在已有视图（用户界面）添加这些新字段的话，参见[第九章 后端视图](https://alanhou.org/odoo-14-backend-views/)中的*修改已有视图 – 视图继承*一节。

##### 扩展知识…

通过`_inherit`经典继承，也可以将父级模型的功能拷贝到一个全新的模型中。这通过添加一个在带有不同标识符的_name类属性来实现。以下是一个示例：

```python
class LibraryMember(models.Model):
     _inherit = 'res.partner'
     _name = 'library.member'
```

新模型有其自己的数据表，包含完全独立于res.partner父模型的自身数据。因其仍继承Partner模型，此后的任意修改也会影响到新模型。

在官方文档中，这被称为原型继承，但在实践中鲜有使用。原因在于代理继承通常可以更高效的方式满足了这一需求，也无需复制数据结构。参见本章中的*使用代理继承将功能拷贝至另一个模型*一节了解更多内容。





##### 原型继承

原型继承通过同时使用`_name`和`_inherit `属性来实现。执行如下步骤来生成对library.book模型的拷贝：

- 在/my_library/models/目录下新建一个library_book_copy.py 文件：

- 在library_book_copy.py 文件中添加如下代码：

  ```python
  from odoo import models, fields, api
   
  class LibraryBookCopy(models.Model):
      _name = 'library.book.copy'
      _inherit = 'library.book'
      _description = "Library Book's Copy"
  ```

- 在/my_library/models/`__init__.py`文件导入一条新的文件引用。修改后的__init__.py文件内容如下

  ```python
  from . import library_book
  from . import library_book_categ
  from . import library_book_copy
  ```

最后，我们需要升级插件模块来让修改生效。查看新模型定义，可访问Settings > Technical > Database Structure > Models菜单。在这里会看到一个新的模型library.book.copy。

> 📝小贴士：要想查看新模型的菜单和视图，需要添加视图及菜单的XML定义。更多有关菜单和视图的相关内容，参见[第三章 创建Odoo插件模块](https://alanhou.org/odoo-14-creating-odoo-add-on-modules/)中的*添加菜单项和视图*一节。



##### 运行原理…

能过同时使用类属性`_name`和`_inherit`，可以拷贝模型的定义。在模型中使用这两个属性时，Odoo会拷贝`_inherit`的模型定义，创建一个带有`_name`属性的新模型。

本例中，Odoo会拷贝library.book模型的定义，创建一个新模型library.book.copy。新的library.book.copy模型有一个包含自身数据的数据表，与父级模型library.book完全独立开来。因其依然继承该父模型，后续的变更还是会影响到这一新模型。

原型继承复制父类中的所有属性。会拷贝字段、属性和方法。如果想在子类中进行修改，只需在子类中添加新的定义。例如，library.book模型有一个_name_get方法。如果希望在子类中使用不同版本的_name_get，需要在library.book.copy模型中重新定义该方法。

> ⚠️警告：在_name和_inherit属性中使用同一个模型名称时原型继承无法生效。如果在_name和_inherit属性中确实使用了相同的模型名称，会和普通扩展继承表现一致。



##### 扩展知识…

官方文档称其为原型继承，但实际开发中很少使用到。原因是代理继承通常会以更高效的方式满足相应的需求，而又无需复制数据结构。更多相关信息，参见下一小节*使用代理继承将功能拷贝至另一个模型*。





##### 代理继承

第三种继承类型是代理继承。使用的不是`_inherit`，而是`_inherits`类属性。

- 有时我们不要修改已有模型，希望根据已有模型创建一个新模型来使用原有功能。
- 这时可以通过拷贝原型继承中的模型定义，但会导致重复的数据结构。
- 如果希望拷贝模型定义而又不复制数据结构，那么答案就是Odoo的代理继承，使用_inherits模型属性（注意这里多一个 s）。



传统继承与面向对象编程的概念有很大不同。而代理继承则与其相似，其中可创建一个新的模型来包含父级模型中的功能。它还支持多态继承，这时从两个或多个其它的模型中进行继承。

我们的图书馆中已经有书了。是时候修改让图书馆也拥有会员了。对于图书会员，我们需要Partner模型中的所有身份和地址数据，也会想要保留一些有关会员的信息：起始日期、结束日期和会员卡号。

向Partner模型添加这些字段不是最好的方案，因为对于非会员的成员们无需使用到这些。使用一个带有额外字段的新模型继承Partner模型则会非常好。

##### 如何实现…

新图书会员模型应有自己的独立Python代码文件，但为保持讲解尽可能简单，我们将复用models/library_book.py文件：

- 添加新模型继承res.partner

  ```python
  class LibraryMember(models.Model):
       _name = 'library.member'
       _inherits = {'res.partner': 'partner_id'}
       partner_id = fields.Many2one(
           'res.partner',
           ondelete='cascade')
  ```

- 接下来，我们将添加针对图书会员的字段

  ```python
  # class LibraryMember(models.Model):
       # ...
       date_start = fields.Date('Member Since')
       date_end = fields.Date('Termination Date')
       member_number = fields.Char()
       date_of_birth = fields.Date('Date of birth')
  ```

- 此时，我们应升级该插件模型来让修改生效。



##### 运行原理…

`_inherits`模型属性设置我们想要继承的父级模型。本例中只有一个 – res.partner模型。

- 它的值是一个键值对字典，键是被继承的模型，而值是用于关联它们的字段名。
- 这些是我们必须同时在模型中定义的Many2one字段。本例中，partner_id是用于关联父级模型Partner的字段。



为更好理解它如何运行，我们来看在新建会员时数据库级别上会发生什么：

- 在res_partner表中新建一条记录
- 在library_member表中新建一条记录
- library_member表中的partner_id字段设置为所创建的res_partner记录的id



会员记录自动关联到一个新的Partner记录。它仅是一个 many-to-one关联，但代理机制注入了一些魔力来让Partner的字段看起来就好像属于Member的记录一样，新的Partner记录会自动和新的会员记录一同创建。

你可能会想要知道这个自动创建的Partner记录并没有什么特别的。这是一个常规的Partner，如果查看Partner模型，就会看到这条记录（当然其中不包含那些额外的会员数据）。所有的会员都是成员（Partner），但只有部分成员是会员。

那么在删除同时还是会员的成员时会发生什么呢？可通过关联字段的ondelete值来进行决定。对partner_id我们使用了cascade。这表示删除成员会同时删除对应的会员。我们可以使用更为保守的设置restrict来禁止在有关联会员时删除成员。这样的话只有删除会员时才会有效。

需要注意代理继承仅用于字段，而不能用于方法。因此，如果Partner模型有一个do_something()方法，成员模型不会自动继承它。



##### 扩展知识…

对于这个继承代理有一个快捷方式。代替创建一个`_inherits`字典，可以在Many2one字段定义中使用delegate=True属性。这和`_inherits`选项的功能完全一样。其主要优点是更为简洁。在给出的示例中，我们执行了与前述相同的继承代理 ，但在这种情况下，我们对partner_id字段使用了delegate=True选项来代替`_inherits`字典的创建：

```python
class LibraryMember(models.Model):
     _name = 'library.member'
     partner_id = fields.Many2one('res.partner', '代理继承', ondelete='cascade', delegate=True)
     date_start = fields.Date('Member Since')
     date_end = fields.Date('Termination Date')
     member_number = fields.Char()
     date_of_birth = fields.Date('Date of birth')
```



关于代理继承一个值得注意的用例是用户模型 res.users。它继承自成员（res.partner）。这表示其中在User中可见的一些字段实际存储在Partner模型中（尤其是name字段）。在新用户创建时，我们还获取了一个新的自动创建的Partner。

还应说明带有_inherit的传统继承会将功能拷贝到新模型中，虽然效率并不高。这在*使用继承向模型添加功能*一节中进行了讨论。



##### 使用抽象模型实现可复用模型功能

有时，会有一个具体的功能，我们希望添加到几个不同的模型中。在不同的文件中重复相同代码基本上是一种不良编程实践，最好可以一次实现多次复用。

抽象模型让我们可以创建一个通用模型来实现一些功能，然后由普通模型进行继承以使用该功能。

作为示例，我们将实现一个简单的存档功能。它将active字段加入到模型中（如果尚未存在）并添加一个存档方法来切换active标记。这可以生效是因为active是一个魔法字段，如果默认在模型中出现，active=False 的记录会在查询中被过滤掉。

下面我们将在图书模型中添加它。

##### 准备工作

本节中，我们继续使用上一节中的my_library插件模型。

##### 如何实现…

存档功能显然可独立为一个插件模块或者至少应有自己的Python代码文件。但为保持讲解尽可能简单，我们将会把它塞到models/library_book.py文件中：

- 为存档功能添加抽象模型。应在使用它的图书模型中定义

  ```python
  class BaseArchive(models.AbstractModel):
       _name = 'base.archive'
       active = fields.Boolean(default=True)
       def do_archive(self):
           for record in self:
              record.active = not record.active
  ```

- 接着，我们编辑图书模型来继承存档模型

  ```python
  class LibraryBook(models.Model):
       _name = 'library.book'
       _inherit = ['base.archive']
       # ...
  ```

- 需要对插件模块进行升级来让修改生效。



##### 运行原理…

- 抽象模型基于models.AbstractModel的类进行创建，而非常用的models.Model。

- 它拥有常规模型的所有属性和功能，区别在于ORM不会在数据库中创建实际的体现。

- 这表示它不能存储任何数据。仅用作添加到常规模型中的可复用功能的一个模板。

我们的存档抽象模型非常简单，仅添加active字段和一个方法来切换active标记的值，我们将在稍后在用户界面中通过按钮进行使用。

模型类中定义了_inherit属性时，它继承那些类中的属性方法，定义在当前类中的属性方法对这些继承功能进行修改。

这里所采用的机制与常规模型继承相同（如*使用继承向模型添加功能*一节）。你可能注意到了`_inherit`使用一个模型标识符列表而不是带有一个模型标识符的字符串。其实_inherit可以使用这两种形式。

- 使用列表形式允许我们继承多个（通常是抽象）类。
- 在本例中，我们仅继承了一个类，因此使用文本字符串也没有问题。

为进行演示我们使用了列表。



##### 扩展知识…

值得注意的内置抽象模型是mail.thread，这由mail（Discuss）插件模块提供。在模型中它启用讨论功能来驱动在不同表单底部看到的消息墙。

AbstractModel外，还有第三种模型类型：models.TransientModel。像models.Model它有一个数据库体现，但所创建的记录供临时使用，会定期由服务端调度任务清除。除此之后，临时模型（也译作瞬态模型）和常规模型的功能一致。

models.TransientModel对于称之为向导的更为复杂的用户交互会非常有用。向导用于请求用户输入。在[第八章 高级服务端开发技巧](https://alanhou.org/odoo-14-advanced-server-side-development-techniques/)中，我们探讨如何使用它们来实现高级用户交互。

![Odoo 14开发者指南第四章 应用模型](https://i.cdnl.ink/homepage/wp-content/uploads/2021/01/2021010414461579.jpg)







##### 继承模型demo

```python
from odoo import models, fields, api

class father(models.Model):
     '''父表'''
     _name = 'father'
     name = fields.Char(string='父名')
     age = fields.Integer(string='父年龄')

class add_father(models.Model):
     '''类继承（扩展）'''
     _inherit = 'father'
     sex = fields.Selection(
          [
               ('man','男'),
               ('woman','女')
          ], string='父性别')

class son(models.Model):
     '''原型继承'''
     _inherit = 'father'
     _name = 'son'

     son_name = fields.Char('子名')
     son_sex = fields.Selection(
          [
               ('man','男'),
               ('woman','女')
          ], string='性别')

class proxy_son(models.Model):
    '''代理继承'''
    _name = 'proxy.son'
    # _inherits = {'father': 'name'}
    # name = fields.Many2one(
    #      'father', string='父名',
    #      ondelete='cascade')
    name = fields.Many2one('father', '父名', ondelete='cascade', delegate=True)
    age = fields.Integer(string='子年龄')

```



##### 抽象继承demo

```python
from odoo import models, fields

class BaseArchive(models.AbstractModel):
     _name = 'base.archive'
     active = fields.Boolean(default=True, string='是否消失')
     def do_archive(self):
         for record in self:
            record.active = not record.active

class LibraryBook(models.Model):
    # 定义表模型名，会把.转为_：library_book
    _name = 'library.book'
    # 添加一个用户友好的模型标题
    _description = 'Library Book'
    # 按时间最近降序排序，然后按标题升序排序。默认是升序
    _order = 'date_release desc, name'
    # 使用short_name字段作为记录
    _rec_name = "short_name"
    _inherit = ['base.archive']

    name = fields.Char('书名', required=True, index=True)
    short_name = fields.Char('简名', translate=True, index=True)
    notes = fields.Text('笔记')
    state = fields.Selection(
        [('draft', '草稿'),
         ('available', '发行'),
         ('lost', '失效')],
        'State', default="draft")
    description = fields.Html('描述', sanitize=True, strip_style=False)
    cover = fields.Binary('图片')
    out_of_print = fields.Boolean('是否打印')
    date_release = fields.Date('创建日期', default=fields.Datetime.now)
    date_updated = fields.Datetime('更改日期')
    pages = fields.Integer('整书页数',
                           groups='base.group_user',
                           states={'lost': [('readonly', True)]},
                           help='整书页数', company_dependent=False)
    reader_rating = fields.Float(
        '书但平均分',
        digits=(14, 1),  # 可选精度 (total, decimals),
    )

    # Odoo使用**伙伴模型res.partner**来表示人、组织和地址
    author_ids = fields.Many2many('res.partner', string='作者')
    cost_price = fields.Float('花费金额', digits='Book Price')

    currency_id = fields.Many2one('res.currency', string='Currency')
    # 可选属性currency_field='currency_id'，在币种字段使用currency_id之外的名称时使用
    retail_price = fields.Monetary('售卖价格')

    publisher_ids = fields.Many2one(
        'res.partner', string='所属出版社',
        # optional:
        ondelete='set null', context={}, domain=[],
    )
    category_id = fields.Many2one('library.book.category', string='书所属类')

    def name_get(self):
        """本方法用于自定义记录的显示名称"""
        result = []
        for record in self:
            rec_name = "%s (%s)" % (record.name, record.date_release)
            result.append((record.id, rec_name))
        return result
```

