



##### 向模型添加关联字段

Odoo模型之间的关联通过关联字段来体现。有三种不同的关联类型：

- **many-to-one**, 常缩写为m2o
- **one-to-many**, 常缩写为o2m
- **many-to-many**, 常缩写为m2m

以图书应用为例，我们知道每本书只有一个出版社，因此在图书和出版社之间可以使用 many-to-one 关联。

而每个出版社都可以出版多本书。因此对前面的many-to-one 关联表示存在一个反向的one-to-many 关联。

最后，某些情况下我们会有many-to-many关联。在本例中，每本书可以有多个作者。而反过来每位作者也可以写多本书。从任意一方看，这都是一个many-to-many关联。



Odoo使用**伙伴模型res.partner**来表示人、组织和地址。对于作者和出版社我们应使用它。我们将编辑models/library_book.py文件来添加这些字段：

- 向图书模型添加图书出版商的many-to-one字段

  ```python
  class LibraryBook(models.Model):
      # ...
      publisher_id = fields.Many2one(
          'res.partner', string='Publisher',
          # optional:
          ondelete='set null',
          context={},
          domain=[],
      )
  ```

- 为出版社的书籍添加one-to-many字段，我们需要继承partner模型。为进行简化，我们在同一Python文件中添加

  ```python
  class ResPartner(models.Model):
      _inherit = 'res.partner'
      published_book_ids = fields.One2many(
          'library.book', 'publisher_id',
          string='Published Books')
  ```

  📝我们这里使用的`_inherit`属性用于继承已有模型。这一点会在本章后面的*使用继承向模型添加功能*一节中进行讲解。

- 我们已在图书和作者之间创建了一个many-to-many关联，让我们再次查看一下

  ```python
  class LibraryBook(models.Model):
       # ...
       author_ids = fields.Many2many(
          'res.partner', string='Authors')
  ```

- 相同的关联，但是作者对图书的关联，应加入到partner模型中：

  ```python
  class ResPartner(models.Model):
       # ...
       authored_book_ids = fields.Many2many(
           'library.book',
           string='Authored Books',
           # relation='library_book_res_partner_rel' # optional
       )
  ```

此时升级该插件模块，新字段就可以在模型中使用了。需要先将它们添加到视图中才会显示，但在开发模式下我们可以通过Settings > Technical > Database Structure > Models来查看模型字段是否添加成功。





##### 运行原理…

- **Many-to-one**字段向模型的数据表中添加了一列，存储关联记录的数据库ID。在数据库级别上，还会创建外键约束，确保保存的ID是对关联表中记录的有效引用 。对这些关联字段不会创建数据库索引，但这可通过添加 index=True 属性来进行完成。

- 我们可以看到对many-to-one字段还可以使用另外的4个属性。
  - ondelete属性决定在关联记录删除时执行什么操作。例如，在出版社记录删除后图书会怎么样？
    - 默认值为’set null’,，会将该字段置为空值。
    - 也可以为’restrict’，会阻止关联字段的删除，
    - 或者是 ‘cascade’，这会导致关联的字段同样被删除。

- 最后的两个属性（context和domain）对其它的关联字段同样有效。这些大多在客户端更具意义，在模型层次上，它们作为会在客户端视图中使用的默认值。

  - 在点击字段进入关联记录视图时context会向客户端上下文添加变量。
    - 例如，我们可以使用它来为新记录设置通过该视图创建的默认值。
  
  - domain是用于限制可用的关联记录列表的搜索过滤器。

context和domain都将在[第十章 后端视图](https://alanhou.org/backend-views/)中进行更详细的讲解。

One-to-many字段是many-to-one的反向关联，虽然它们像其它字段一样添加在模型中，在数据库中并没有实际的体现。他们仅是编程捷径，启用视图来展现这些关联记录列表。

Many-to-many关联也不会向模型数据表添加列。这类关联在数据库中使用中间关联表进行体现，其中有两列分别存储这两个关联的ID。在图书和作者之间添加新关联在这个关联表中使用图书ID和作者ID创建一条新记录。

Odoo自动处理这一关联表的创建。关联表的名称默认使用两个关联模型名按字母排序加上一个**_rel**后缀来创建。但我们可以使用relation属性来进行覆盖。

> ℹ️需要考虑的一种情况是两个表名过长导致自动生成的数据库标识符超过PostgreSQL的上限63个字符。按照经验，如果两个关联的表名超过23个字符时，应使用relation属性来设置一个更短的名称。下一节中，我们将进行更深入的讨论。



##### 扩展知识…

Many2one字段支持一个额外的auto_join属性。这个标记允许ORM对这个字段使用SQL连接（join）。因此它不受普通的ORM限制，如用户访问控制和记录权限规则。在具体的用例中，它可以解决性能问题，但建议尽量避免使用。

我们讲解了定义关联字段的最简短的方式。下面来看针对这一字段类型的具体属性。

One2many的字段属性如下：

- comodel_name：这是目标模型标识符，对所有关联字段是强制的，但可以在对应位置定义而无需使用关键字
- inverse_name：它仅应用于One2many，是反向Many2one关联的目标模型中的字段名
- limit：它在One2many和Many2many中使用，对在用户界面级别上用于记录读取的数量设置可选限制

Many2many的字段属性如下：

- comodel_name：它的功能与One2many字段中相同
- relation：这是用于支持关联的数据表的名称，覆盖自动定义的名称
- column1：这是连接这个模型的关联表中的Many2one字段的名称
- column2：这是在关联数据表中连接comodel的Many2one字段的名称

对于Many2many在大多数情况下，ORM会处理这些属性的默认值。它甚至可以监测反向的Many2many关联，监测已有关联表及恰当地对调column1和column2的值。

但是，有两种情况我们需要介入并为这些属性提供自己的值。

- 一种情况是我们需在相同的两个模型中添加一个以上的Many2many关联。这时，我们必须为第二个关联提供关联表名，且应与第一个关联不同。
- 另一种情况是在自动生成的关联数据表名长度超过PostgreSQL对于数据对象名的上限63个字符时。

自动生成的关联表名为`<model1>_<model2>_rel`。但关联表还会为这一关联名创建一个主键索引，标识符如下：

```python
<model1>_<model2>_rel_<model1>_id_<model2>_id_key
```

这个主键也需要满足63个字符的上限。因此，如果两个表名组合起来超过63个字符，会无法满足这一上限并需要手动设置relation属性。



##### 向模型添加等级

等级（Hierarchy） 的表现就像是模型与自身存在着关联，每条记录在相同模型中有一条父级记录以及多条子记录。这只需通过在模型和自身之间建立many-to-one关联来进行实现。

但是，Odoo通过使用[嵌套集合模型](https://en.wikipedia.org/wiki/Nested_set_model)来对这类字段提供更好的支持。在启用后，在它们的域过滤器中使用**child_of**运算符进行查询会显著地提升速度。

继续使用图书示例，我们将创建一个等级分类树来用于图书分类。

我们会为分类树新建一个Python文件models/library_book_categ.py，如下：

- 在models/`__init__.py`中载入如下行来加载新的Python代码文件

  ```python
  from . import library_book_categ
  ```

- 创建models/library_book_categ.py 文件并加入如下代码来为图书分类模型创建父子关联

  ```python
  from odoo import models, fields, api
  class BookCategory(models.Model):
      _name = 'library.book.category'
      name = fields.Char('Category')
      parent_id = fields.Many2one(
          'library.book.category',
          string='Parent Category',
          ondelete='restrict',
          index=True)
      child_ids = fields.One2many(
          'library.book.category', 'parent_id',
          string='Child Categories')
  ```

- 同时添加如下代码来启动特别的等级支持

  ```python
  _parent_store = True
  _parent_name = "parent_id" # optional if field is 'parent_id'
  parent_path = fields.Char(index=True)
  ```

- 在模型中添加如下行来新增一个防止循环关联的检查

  ```python
  from odoo.exceptions import ValidationError
  ...
  @api.constrains('parent_id')
  def _check_hierarchy(self):
       if not self._check_recursion():
           raise models.ValidationError('Error! You cannot create recursive categories.')
  ```

- 这时，我们需要向图书分配一个分类。我们将在library.book模型中新增一个many2one字段进行实现

  ```python
  category_id = fields.Many2one('library.book.category')
  ```

- 最后，升级模型来让这些修改生效。

  📝要在用户界面中显示library.book.category模型，需要添加菜单、视图和权限规则。更多相关内容请参见[第三章 创建Odoo插件模块](https://alanhou.org/odoo-14-creating-odoo-add-on-modules/)。你也可通过访问[GitHub 仓库](https://github.com/alanhou/odoo14-cookbook)来获取代码。

![Odoo 14开发者指南第四章 应用模型](https://alanhou.org/homepage/wp-content/uploads/2019/05/2019060213323546.jpg)

##### 运行原理…

- 第1和第2步中新建了一个带有等级关联的模型。
  - Many2one关联添加了一个引用父级记录的字段。
  - 为进行更快速的子记录发现，这个字段使用**index=True**参数在数据库中进行了索引。
  - parent_id字段应将ondelete设置为’cascade’ 或’restrict’。
  - 到这里，我们拥有了实现等级结构所需的所有内容，但还需要做一些增添来对其进行改善。
  - One2many关联不会在数据库中添加额外的字段，但提供了一个访问父级为该记录的所有记录的快捷方式。

- 在第3步，我们启动了对于等级的特别支持。这对于**高读取低写入指令非常有用**，因为它通过更大的写入运算开销带来了更快速的数据浏览。

  - 这通过添加一个帮助字段**parent_path**及设置模型属性为 `_parent_store=True`来实现。

  - 在启用了这个属性之后，该帮助字段会用于在等级树的搜索中存储数据。

  - 默认，它假定记录的父级字段名为parent_id，但也可以使用不同的名称。

  - 这种情况下，正确的字段名应使用额外的模型属性_parent_name来进行表明。默认值如下：

    ```
    _parent_name = 'parent_id'
    ```



推荐使用第4步来防止等级中的循环依赖，即在上级树和下级树中都包含同一条记录。这对于通过树导航的程序非常的危险，因为会进入到无限死循环。models.Model为此提供了一个工具方法（_check_recursion），我们在这里进行了复用。

第5步为向library.book添加一个类型为many2one的category_id字段，这样我们可以对图书记录设置分类。这个只是为完成我们的示例。



##### 扩展知识…

这里所展示的技术应该用于静态等级，即经常进行读取和查询但更新却不频繁。

图书分类是一个很好的示例，因为图书馆不会持续地新建分类，但读者会经常将搜索限定到分类或子分类中。

这么说的原因是实现是在数据库中的嵌套集合模型中，要求在插入、删除或修改分类时更新所有记录的parent_path列（以及相关联的数据库索引）。

**那会非常耗资源**，尤其是在并行事务中执行多个编辑的情况下。

> **📝小贴士：**如果你在处理极为动态的等级结构，标准的parent_id和child_ids关联会通过避免表级锁来达成更好的性能。



##### 向模型添加约束验证

模型可拥有阻止它们输入不想要的条件的验证。

Odoo支持两种不同类型的约束：

- 数据库级别的约束检查
- 服务端级别的约束检查

数据库级别的约束由**PostgreSQL所支持的约束**进行限制。

- 最常用的是UNIQUE约束
- 但也可使用CHECK和EXCLUDE约束。
- 如果这还无法满足需求，可以编写Python代码来使用Odoo服务端级别的约束。

我们将使用[第三章 创建Odoo插件模块](https://alanhou.org/odoo-14-creating-odoo-add-on-modules/)中所创建的图书模型，并向其添加一些约束。我们会添加一个数据库约束来防止重复的书名，以及一个 Python 模型约束来防止使用未来的日期作为发行日期。



本节中，我们继续使用上一节中的在library.book模型。我们预期它至少应包含如下内容

```python
from odoo import models, fields
class LibraryBook(models.Model):
     _name = 'library.book'
     name = fields.Char('Title', required=True)
     date_release = fields.Date('Release Date')
```



我们将在models/library_book.py Python文件中编辑LibraryBook类

- 添加模型属性来创建数据库约束

  ```python
  class LibraryBook(models.Model):
       # ...
      _sql_constraints = [
          ('name_uniq', 'UNIQUE(name)', 'Book title must be unique.'),
          ('positive_page', 'CHECK(pages>0)', 'No. of pages must be positive')
      ]
  ```

- 添加一个模型方法来创建Python代码约束

  ```python
  from odoo import api, models
  from odoo.exceptions import ValidationError
  class LibraryBook(models.Model):
       # ...
       @api.constrains('date_release')
       def _check_release_date(self):
           for record in self:
               if record.date_release and
                  record.date_release > fields.Date.today():
                  raise models.ValidationError('Release date must be in the past')
  ```

- 在对这些代码文件进行修改后，需要升级模块并重启服务。



##### 运行原理…

第1步在模型表中创建了一个数据库约束。这是在数据库级别进行的强制。_sql_constraints模型属性接收一个待创建的约束列表。每个约束由一个三个元素的元组定义，如下所示：

- 约束标识符所使用的后缀。本例中，我们使用了name_uniq，产生的约束名称为library_book_name_uniq。
- PostgreSQL中用于修改或创建数据表的SQL指令。
- 在违反约束时向用户报出的消息。

本例中，我们使用了两个SQL约束。第一个是唯一书名，第二个是检测页数是否为正数。

> ⚠️警告：如果通过模型继承向已有模型添加约束的话，请确保不存在违反约束的数据行。如果存在这类数据，则无法添加SQL约束，在日志中会报错。

我们在前面已经提到，也可以使用其它数据表约束。注意字段级约束如NOT NULL不能以这种方式进行使用。有关PostgreSQL的通用约束以及具体的数据表约束更详细的信息，请参见http://www.postgresql.org/docs/current/static/ddl-constraints.html。

在第2步中，我们添加了一个方法来执行Python代码验证。它使用了**@api.constrains装饰器**，表示在参数列表中字段发生变化时应执行它来运行检查 。如果检查失败，会抛出一个ValidationError异常。

##### 扩展知识…

通常如果有复杂的验证约束，可以使用@api.constrains，但对于简单用例，也可以使用带有CHECK选项的_sql_constraints。看看下面的示例：

```python
_sql_constraints = [
    ('check_credit_debit', 'CHECK(credit + debit > 0 AND credit * debit = 0)', 'Wrong credit or debit value in accounting entry!'),
]
```

上例中我们使用了CHECK选项，并使用AND运算符在同一约束中进行多条件检测。





##### 暴露存储在其它模型中的关联字段

在从服务端读取数据时，Odoo客户端仅能获取模型中存在的字段及查询的值。客户端代码不同于服务端，无法使用点号标记来获取关联表中的数据。

但是，这些字段可通过将它们添加为关联字段来进行访问。我们将会让图书模型中的出版社城市可以被访问。

##### 准备工作

本节中，我们继续使用上一节中的my_library插件模型。

##### 如何实现…

编辑models/library_book.py文件添加一个新关联字段：

- 确保我们有一个图书出版社的字段（此前示例中已添加过）

  ```python
  class LibraryBook(models.Model):
       # ...
       publisher_id = fields.Many2one(
           'res.partner', string='Publisher')
  ```

- 接着，为出版社城市添加一个关联字段：

  ```python
  # class LibraryBook(models.Model):
       # ...
       publisher_city = fields.Char(
           'Publisher City',
           related='publisher_id.city',
           readonly=True)
  ```

- 最后，我们需要升级该插件模块来让新字段在模型中可用。



##### 运行原理…

关联字段和普通字段相似，但是有一个额外的属性related，带有一个分隔字段链遍历的字符串。

在本例中，我们通过publisher_id访问出版社的关联记录，然后读取它的city字段。还可以使用更长的链表达式，例如publisher_id.country_id.country_code。

注意在本节中，我们设置关联字段为只读。如果不这么做，字段将为可写，用户可能会修改其值。这会产生修改关联出版社城市字段值的影响。这可能会既有用又有副作用，在操作时应小心；所有由相同出版社出版的图书的publisher_city都会被更新，这可能会在用户的预料之外。

##### 扩展知识…

关联字段实际上是计算字段。只是提供了一种方便的快捷语法来从关联模型读取字段值。作为一个计算字段，意味着也可以使用store属性。作为快捷方式，它们也拥有引用字段的所有属性，如name, translatable和required。

此外，它支持一个类似compute_sudo的related_sudo标记，在设置为True时，字段链遍历时会在不进行用户权限检查。

> **📝小贴士：**在create()方法中使用关联字段会影响到性能，因此这些字段的计算会延迟到它们创建结束的时候。因此 ，如果有一个One2many关联，如sale.order和sale.order.line模型，又在line模型的关联字段上引用了订单模型的字段，应当在记录创建时在订单模型中显式地读取该字段，而不是使用关联字段快捷方式，尤其是在有很多订单条目（line）时。



##### 使用引用字段添加动态关联

对于引用字段，首先我们需要决定关联的目标模型（或称comodel）。但有时我们会让用户来做决定，首先选定我们所要的模型然后记录想要关联的记录。

在Odoo中这通过使用引用字段来实现。

##### 准备工作

本节中，我们继续使用上一节中的在library.book模型。

##### 如何实现…

编辑models/library_book.py文件来添加新的关联字段：

- 首先，我们需要添加一个帮助方法来动态构建一个可选目标模型列表：

  ```python
  from odoo import models, fields, api
  class LibraryBook(models.Model):
       # ...
       @api.model
       def _referencable_models(self):
           models = self.env['ir.model'].search([
               ('field_id.name', '=', 'message_ids')])
           return [(x.model, x.name) for x in models]
  ```

- 然后，我们需要添加引用字段并使用上述的函数提供一个可选模型列表

  ```python
  ref_doc_id = fields.Reference(
      selection='_referencable_models',
      string='Reference Document')
  ```

- 因为我们修改了模型的结构，需要升级模块来使这些修改生效。



##### 运行原理…

引用字段类似于many-to-one字段，不同的是它们允许用户选择要关联的模型。

目标模型可通过由selection属性提供的列表进行选择。selection属性应是一个包含两个元素的元组，第一个元素是模型的内部标识符，第二个是它的描述文本。

以下是一个示例：

```python
[('res.users', 'User'), ('res.partner', 'Partner')]
```

但是，不需要提供一个固定的列表，我们可以使用大部分通用的模型。为进行简化，我们使用带有消息功能的所有模型。使用_referencable_models方法，我们动态地提供了一个模型列表。

本节一开始提供了一个函数来浏览所有模型记录，可供动态引用来创建用于提供给selection属性的列表。虽然两种形式都允许，我们在引号内声明了函数名，而不是不加引号直接引用函数。这更为灵活，比如它允许所引用的函数可以在代码的后面进行定义，在使用直接引用时则不能这么做。

该函数需要一个@api.model装饰器，因为它在模型级别而非记录集级别上进行操作。

> 📝虽然这个功能看起来很棒，它运行的开销会很大。使用引用字段显示大量记录（如在列表视图中）会带来很重的数据库负载，因为每个值都需在一个单独的查询中进行查找。它也不能像常规关联字段那样利用数据库的引用一致性。





