在编写插件模块时所选择的数据模型可能会存在一些问题，因此会需要在插件模块的使用过程中对其进行调整。为允许这一操作而又无需过多技巧，Odoo支持插件模块中使用版本号并在需要时执行迁移。



##### 如何实现…

我们假定在模块的早前版本中date_release字段是一个字符字段，人们可以填写任意他们认为是日期的字段。现在我们意识到需要对这一字段进行比较和聚合运算，因此需要将它的类型修改为Date。

Odoo在类型转换上做了很大的优化，但在这种情况下得靠我们自己了，因此我们需要给出指令来对已安装在数据库中的早前版本进行转换来让当前版本可以运行。按照如下步骤进行操作：

```python
def migrate(cr, version):

    cr.execute(‘ALTER TABLE library_book RENAME COLUMN date_release

                                              TO date_release_char’)
```

- 提升`__manifest__.py`文件中的版本号

  ```
  'version': '14.0.1.0.1',
  ```

- 在migrations/14.0.1.0.1/pre-migrate.py中提供预迁移代码（migrations与models、views等目录处同一目录级）

  ```python
  def migrate(cr, version):
      cr.excute("""
      ALTER TABLE library_book 
      RENAME COLUMN date_release TO date_release_char""")
  ```

- 在migrations/14.0.1.0.1/post-migrate.py中添加一个迁移后代码

  ```python
  from datetime import date
  
  from odoo import fields
  
  
  def migrate(cr, version):
      cr.execute('SELECT id, date_release_char FROM library_book')
      for record_id, old_date in cr.fetchall():
          # check if the field happens to be set in Odoo's internal format
          new_date = None
          try:
              new_date = fields.Date.to_date(old_date)
          except ValueError:
              if len(old_date) == 4 and old_date.isdigit():
                  # probably a year
                  new_date = date(int(old_date), 1, 1)
              else:
                  # try some separators, play with day/month/year order...
                  pass
          if new_date:
              cr.execute('UPDATE library_book SET date_release=%s', (new_date,))
  ```

- 没有这代码，Odoo会将原来的date_release列重命名为date_release_moved并新建一列，因为没有字符字段对日期字段的直接自动转换。从用户的角度看，date_release的数据会消失。



##### 运行原理…

第一个重要的点是在插件中增加版本号，因为迁移仅在不同版本间进行。在每次更新期间，Odoo在更新时将声明文件中的版本号写入到ir_module_module表中。

如果版本号小于或等于3部分时，前缀使用Odoo的大版本和小版本号。

前例中，我们显式地使用了Odoo的大小版本号，这是一种良好实践，但1.0.1也可以达到同样的效果，因为在内部，Odoo会为短版本号添加其大版本和小版本号。通常，使用长标记是一种不错的做法，因为很容易地看出它是针对Odoo的哪一个版本的。

两个迁移文件是无需在任何地方注册的代码文件。在更新插件时，Odoo对比在ir_module_module中记录的版本号与插件声明文件中所添加的版本号。如果声明文件的版本号更高（在添加了 Odoo 的大版本和小版本之后），会搜索这一插件的migrations文件夹，查看它是否包含带有范围内版本号的文件夹，包含当前更新的版本号。

然后，在查找到的文件夹内，Odoo搜索以pre-开头的Python文件，加载它们，并预设其中定义了名为migrate的函数，该函数有两个参数。此函数调用时以数据库游标作为第一个参数以及当前安装的版本号作为第二参数。这一时间在Odoo查找插件定义的其它代码之前，因此你可以假定你的数据库结构对比此前版本没有做过任何修改。

在所有预迁移函数成功调用之后，Odoo加载模型以及插件中所定义的数据，这会导致数据库结构的变化。例如我们在pre-migrate.py文件中重命名了date_release，Odoo会以正确的数据类型使用该名称新建一列。

此后，通过同样的搜索算法，会搜索post-migrate文件并在找到时进行执行。本例中，我们需要查看所有的值来了解我们是否能借助它让一些数据可以使用，否则我们会保持数据为NULL。除非绝对必要不要编写遍历整表的脚本，在这种情况下，我们可能会编写一个很大且可读性差的SQL的switch语句。

> 📝**重要贴士：**如果你仅仅是想要重命名一列，则无需编写迁移脚本。此时可以将oldname参数设置为需修改的字段原列名，然后Odoo会自己处理重命名。



##### 扩展知识…

在预迁移和迁移后的步骤中，仅能访问到游标，如果你习惯于使用Odoo环境则不是很方便。

它可能会导致在这一阶段使用模型预料外的结果，因为在预迁移步骤中，插件模型尚未被载入，同时，在迁移后步骤中，由依赖当前插件的插件定义的模型也还未被加载。

但是，如果这对于你来说不是问题，也许是因为你想要使用你的插件所不涉及的模型或者是你已知这不会是一个问题的模型，那么就可以编写如下代码创建一个习惯的环境：

```python
from odoo import api, SUPERUSER_ID

def migrate(cr, version):
  env = api.Environment(cr, SUPERUSER_ID, {})
  # env holds all currently loaded models
```



##### 其它内容

在编写迁移脚本时，常常会碰到重复的任务，比如查某数据列或数据表是否存在、重命名或映射一些旧的值到新值。重复造轮子可能会容易产生问题并让人沮丧，如果可以接受额外依赖的话考虑使用https://github.com/OCA/openupgradelib。