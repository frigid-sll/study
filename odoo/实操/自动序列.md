##### Models.py

```
code = fields.Char(string="编号")

@api.model
def create(self, vals):
    vals['code'] = self.env['ir.sequence'].next_by_code('demand.application')
    return super(DemandApplication, self).create(vals)
  
```



##### /data/data.xml

```
<?xml version="1.0" encoding="utf-8"  ?>
<odoo>
    <data noupdate="0">
        <record id="demand_application_code" model="ir.sequence">
            <field name="name">编号</field>
            <field name="code">demand.application</field>
            <field name="prefix">XQ%(year)s%(month)s%(day)s</field>
            <field name="padding">3</field>
<!--            <field name="employee_id" eval="False"/>-->
        </record>
    </data>
</odoo>
```



##### 要在`__manifest__.py`引入data.xml

```
# -*- coding: utf-8 -*-
{
    'name': "demand_management",

    'summary': """
        Short (1 phrase/line) summary of the module's purpose, used as
        subtitle on modules listing or apps.openerp.com""",

    'description': """
        Long description of module's purpose
    """,

    'author': "My Company",
    'website': "http://www.yourcompany.com",
    'category': 'Uncategorized',
    'version': '0.1',
    'depends': ['base', 'hr'],
    'data': [
        'security/ir.model.access.csv',
        'views/module_master_data_views.xml',
        'views/demand_application_views.xml',
        'views/unlink_views.xml',
        'views/unlink_module_views.xml',
        'data/data.xml',
        'views/menu.xml',
    ],
    # only loaded in demonstration mode
    # 'demo': [
    #     'demo/demo.xml',
    # ],
}

```





##### 新建序列

因为序列也是odoo中的对象，因此新建的方法同普通的odoo模型创建的方法一致。通常一个序列包含如下的关键项：

- name: 序列名称
- code: 序列代码，通常为实现的模型名称
- implemetiton: 实现方式。序列有两种实现方式，一种为标准方式(Strandard）,另外一种为非间断式(No gap)。两者的区别在于，标准方式允许中间断层(1,2,4,6)，而非间断式即不允许断层(1,2,3,4)。非间断式的性能开销要大于标准方式。
- prefix: 前缀，即生成的序列号的前缀。
- suffix: 后缀，即生成的序列号的后缀。
- padding: 序列不包含前缀和后缀的长度。
- step: 步长，即序列号增长的长度，默认值为1。
- number_next_actual: 下一序列号数字。

其中，prefix和suffix中可以使用如下的时间变量：

```
Current Year with Century: %(year)s
Current Year without Century: %(y)s
Month: %(month)s
Day: %(day)s
Day of the Year: %(doy)s
Week of the Year: %(woy)s
Day of the Week (0:Monday): %(weekday)s
Hour 00->24: %(h24)s
Hour 00->12: %(h12)s
Minute: %(min)s
Second: %(sec)s
```



##### 获取序列

ir.sequence对象提供了获取下一个序列号的方法: next_by_code.

```python
@api.model
def next_by_code(self, sequence_code, sequence_date=None):
    pass
```

next_by_code方法接收两个参数：

- sequence_code: 序列代码
- sequence_date: 序列日期。使用指定日期内的序列。









##### 一：使用xml注册序列

data/sequence.xml  记得注册到__manifest__.py

```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">

        <record id="it_equipment_sequence" model="ir.sequence">
            <field name="name">it_equipment_sequence</field>
            <field name="code">it_equipment.seq</field>
            <field name="prefix">T%(range_year)s</field>
            <field name="padding">8</field>
        </record>

    </data>
</odoo>
```

这时，你在技术-序列，就可以看到定义的序列了。也能看到prefix的各种变量

使用range_就是会在改变这个变量值的时候重新从1开始计算了。



##### 二：使用序列

model.py

创建时获取（会跳号）

```
 asset_code = fields.Char(string='资产编码', default=lambda self: self.env['ir.sequence'].next_by_code('it.equipment.seq'))
```

保存时获取（不跳号）

```
@api.model
def create(self, vals):
    # We generate a standard reference
    vals['asset_code'] = self.env['ir.sequence'].next_by_code('it.equipment.seq') or '/'
    return super(equipment, self).create(vals)
```

 