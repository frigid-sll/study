```python
demand_customer = fields.Many2one('res.partner', string="需求来源客户", domain="[('xz_is_my_company', '=', False), ('user_id', '!=', False), '|', ('xz_partner_type', '!=', False),('xz_partner_type', 'not in', ['E', 'F'])]")

demand_project = fields.Many2one('project.project', string="需求来源项目", domain="[('partner_id', '=', demand_customer)]")

demand_people_ids = fields.Many2many('partner.contact.line', string='客户联系人', domain=lambda self: [('id', 'in', self.demand_customer.xz_new_partner_contract_ids.mapped("link_contract_id").ids)])

@api.onchange('demand_customer')
def onchange_change_demand_people_domain(self):
    self.update({'demand_project': None,
                 'demand_people_ids': None})
    link_contract_queryset = self.demand_customer.xz_new_partner_contract_ids.mapped("link_contract_id")
    demand_people_domain = [('id', 'in', link_contract_queryset.ids)]
    domain = {'demand_people_ids': demand_people_domain}
    return {'domain': domain}
```

- self.demand_customer.xz_new_partner_contract_ids.mapped("link_contract_id")

  - `xz_new_partner_contract_ids`：

    ```
    xz_new_partner_contract_ids = fields.One2many('belong.company', 'link_partner_id', string='客户联系人', store=True)
    ```

  - `belong.company`中有`link_contract_id`

- `link_contract_queryset.ids`
  - `ids`：获取`queryset`的`id`集合
  
- `demand_people_ids`：要被控制字段





##### xml

```
 options="{'no_create': True}"
 不可以创建
 
 
 <field name="employee_id" attrs="{'readonly': [('flag', '!=', 0)]}"/>
 flag!=0时 只读
 
 <field name="demand_people_ids" widget="many2many_tags" options="{'no_create': True}"/>
 多对多只显示关联的一个字段
```





##### Domain

Domain 代表记录集的条件表达式。Domain 是定义模型子集的规则集合。每个规则是一个包含名称、操作和值的三元组

例如，下面是Product模型子集的Domain表达式，“单价大于1000且类型为服务”的记录集：

```
[('product_type', '=', 'service'), ('unit_price', '>', 1000)]
```

多个规则组合时，默认条件组合方式是AND。逻辑运算符&(AND),|(OR),!(NOT)可以用来显示的组合多个规则。它们在前缀位置使用（操作符在参数之前，而不是中间）。例如下面的Domain表达式，含义是"类型为服务或者单价不介于1000和2000之间"



##### 计算字段和默认值

- 说明

  - 字段也可以通过计算获得。在这种情况下，字段的值不是直接检索自数据库，而是通过调用模型的方法来实时计算获得。要创建计算字段，需要设置它的compute属性为方法名。这个计算方法通过计算self的每条记录来设置字段的值。

  - self是一个记录的有序集合，它支持标准的Python集合操作，如len(self)和iter(self)，加上额外的集合操作recs1 + recs2。迭代过程逐个提供self记录，其中每个记录本身是大小为1的集合。你可以通过点记号来访问/分配单个记录上的字段record.name

- 依赖

  - 计算字段的值通常取决于所在记录行的其它字段的值。ORM层期望开发人员使用depends()装饰器来指定计算方法的依赖性。当某些依赖关系被修改后，ORM层通过给定的依赖关系来触发字段的重新计算。

    ```python
    from odoo import models, fields, api
    
    class ComputedModel(models.Model):
        _name = 'test.computed'
    
       name = fields.Char(compute='_compute_name')
       value = fields.Integer()
    
       @api.depends('value')
       def _compute_name(self):        
            for record in self:
               record.name = "Record with value %s" % record.value
    ```

- 默认值

  - 任何字段都可以给出默认值。在字段定义中，添加选项default=x,x可以是Python字面值（bool，int，float，string），也可以是一个有返回值的方法。

    ```python
    name = fields.Char(default="Unknown")
    user_id = fields.Many2one('res.users', default=lambda self: self.env.user)
    ```

    | 参数                        | 解释                                   |
    | --------------------------- | -------------------------------------- |
    | self.env                    | 对象给出了访问请求参数和其他有用的信息 |
    | self.env.cr 或者 self._cr   | 是数据库游标对象，通常用于查询数据库   |
    | self.env.uid 或者 self._uid | 是当前用户的数据库ID                   |
    | self.env.user               | 是当前用户记录                         |
    | self.env.ref(xml_id)        | 返回XML ID对应的记录                   |
    | self.env[model_name]        | 返回给定模型的实例                     |

    



##### onchange 机制

"onchange"机制为客户端界面提供了一种方法，当用户在字段中填写了值，不需要向数据库保存任何内容，就可以更新表单。

例如，假设模型有三个字段amount,unit_price和price，当数量和单价改变时，自动重新计算价格，并在表单界面更新。要实现这个需求，需要定义一个方法，并使用onchange()装饰器，onchange()的参数指定了在那个字段改变时，触发方法。其中self代表表单视图中的记录，你所做的任何更改，self都将立刻反应在表单上。

```python
<!-- content of form view -->
<field name="amount"/>
<field name="unit_price"/>
<field name="price" readonly="1"/>
```

```python
# onchange handler
@api.onchange('amount', 'unit_price')
def _onchange_price(self):
    # set auto-changing field
    self.price = self.amount * self.unit_price
    # Can optionally return a warning and domains
    return {
        'warning': {
            'title': "Something bad happened",
            'message': "It was very bad indeed",
        }
    }
```



##### 模型约束

odoo提供两种方式实现自动验证，python constraints和sql constraints
Python约束通过方法装饰器constraints()来定义，并在记录集上调用这个方法。装饰器参数指定了约束涉及的字段，当涉及的字段中任一发生改变时触发方法执行。如果不满足约束条件，该方法将引发异常：

```python
from odoo.exceptions import ValidationError

@api.constrains('age')
def _check_something(self):
    for record in self:
        if record.age > 20:
            raise ValidationError("Your record is too old: %s" % record.age)
    # all records passed the test, don't return anything
```

