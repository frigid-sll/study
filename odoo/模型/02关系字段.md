##### **多对一：Many2one(comodel_name, string)**

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| comodel_name | 关联模型的名称（字符串）                                     |
| domain       | 在客户端（domain或字符串）上设置候选值的可选域               |
| context      | 处理该字段时在客户端使用的可选上下文（字典）                 |
| ondelete     | 删除关联记录时执行的操作;可选的值是: ‘set null’（置空）, ‘restrict’（抛出错误，阻止删除）, ‘cascade’（同时删除当前记录和关联记录） |
| auto_join    | 是否在搜索该字段时生成JOINs（布尔值，默认为False）           |
| delegate     | 将其设置为True可以从当前模型访问目标模型的字段（对应于_inherits） |
| string       | 字段标签                                                     |

Many2one字段又称为多对一字段，原理就和sql的**外键**一样，指向另一个模型。

在odoo的前端视图中常常以下拉列表的形式出现，通常以前缀_id 的形式定义，就以书籍借阅为例子，

- 一个书籍信息模型**book**
- 一个借阅记录模型**record**

在书籍借阅模型record中定义书籍：定义方式如下：

```python
book_id = fields.Many2one('book',string='Book')
```

其中的book指的是所关联的书籍信息模型，在数据库中的存储形式就是所关联模型的id，当获得了一条借阅记录的话，通过odoo中的orm映射，以self.book_id 的形式得到它所关联的一条书籍信息记录，该字段的常用参数

##### ondelete,可选参数为set null, restrict, cascade 例如：

```python
book_id = fields.Many2one('book',string='Book',ondelete='set null')
```

- set null: 当书籍信息删除时，所关联的借阅记录中的book_id 设置为空值
- cascade: 当书籍信息删除时，所关联的借阅记录也删除
- restrict: 当书籍信息删除时，如果该书籍存在借阅记录，则无法删除该书籍信息

##### domain（传入一个域表达式）

比如我们想创建借阅记录时，只能选择作者为张三的书籍，可以如下设置:

```
book_id = fields.Many2one('book',string='Book',domain=[('author','=','张三')])
```

!注意：domain中的条件过滤针对的是所关联的模型，在上述案例中指的是book，而不是所定义字段的模型。

拓展知识：前端xml中的视图使用Many2one字段时如果想对Many2one字段不可编辑和创建，可以在field标签中添加属性:

```
options="{'no_create_edit':True,'no_create':True}"
```







##### **一对多：One2many(comodel_name, inverse_name, string)**

| 属性         | 说明                                                     |
| ------------ | -------------------------------------------------------- |
| comodel_name | 关联模型的名称（字符串）                                 |
| inverse_name | comodel_name中指向Many2one的字段，指向当前记录（字符串） |
| domain       | 在客户端（domain或字符串）上设置候选值的可选域           |
| context      | 处理该字段时在客户端使用的可选上下文（字典）             |
| auto_join    | 是否在搜索该字段时生成JOINs（布尔值，默认为False）       |
| limit        | 读取记录时使用的可选限制（整数）                         |
| string       | 字段标签                                                 |

简单来说One2many（一对多）就是Many2one（多对一）反过来而已，是一种虚拟的联系，是建立在Many2one的基础上的，不能单独使用。还是以书籍借阅为例子，之前我们通过book_id可以获得一条借阅记录的书籍记录，但是一本书籍可能有着多条借阅记录，这时我们就可以在书籍信息模型里定义这样一个字段，定义方式如下：

```python
records = fields.One2many('record','book_id',string='借阅记录')
```

其中record指的是借阅记录的模型，book_id 指的是在另一个模型中定义的多对一字段。通过orm映射的方式，如果获得了一条书籍信息，那么可以通过.records的方式获得多条借阅的记录集，然后可以对这个记录集进行遍历。

在前端One2many字段的使用方法：

```xml
<field name="records" widget="one2many">
    <tree>
        <field name="name" string="Name"/>
        <field name="create_date" string="Create Date"/>
    </tree>
</field>
```





##### **多对多：Many2many(comodel_name)**

| 属性         | 说明                                           |
| ------------ | ---------------------------------------------- |
| comodel_name | 关联模型的名称（字符串）                       |
| relation     | 存储数据库中关系的表的可选名称（字符串）       |
| column1      | 关联表中字段名称（字符串）                     |
| column2      | 关联表中字段名称（字符串）                     |
| domain       | 在客户端（domain或字符串）上设置候选值的可选域 |
| context      | 处理该字段时在客户端使用的可选上下文（字典）   |
| limit        | 读取记录时使用的可选限制（整数）               |
| string       | 字段标签                                       |

又称之为多对多字段，是一种双向的关系，这种关系一般是通过中间表的方式来维持。这种关系经常使用的场景是用于一些标签，比如说一篇文章可能有多个类别，一个类别下面又可以有许多文章，这时便需要定义一种多对多关系。这种字段的定义一般是通过_ids尾缀的形式，一般的定义方式如下所示：

```xml
article_ids = fields.Many2many('article', String='Atricles')
```

相反在文章模型中也可以定义category_ids 指向类别模型，后端通过.字段名的方法也可以得到相应的记录集。

拓展：前端使用多对多字段以标签的形式显示，使用方法如下:

```xml
<field name="book_ids" widget="many2many_tags"/>
```









#### 操作代码

**一对多：One2many**

| 属性              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| (0, 0,{ values }) | 根据values里面的信息新建一个记录                             |
| (1,ID,{values})   | 更新id=ID的记录（对id=ID的执行write 写入values里面的数据）   |
| (2,ID)            | 删除id=ID的数据（调用unlink方法，删除数据以及整个主从数据链接关系） |



##### **多对多：Many2many**

| 属性            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| (0,0,{values})  | 根据values里面的信息新建一个记录。                           |
| (1,ID,{values}) | 更新id=ID的记录（写入values里面的数据）                      |
| (2,ID)          | 删除id=ID的数据（调用unlink方法，删除数据以及整个主从数据链接关系） |
| (3,ID)          | 切断主从数据的链接关系但是不删除这个数据                     |
| (4,ID)          | 为id=ID的数据添加主从链接关系。                              |
| (5)             | 删除所有的从数据的链接关系就是向所有的从数据调用(3,ID)       |
| (6,0,[IDs])     | 用IDs里面的记录替换原来的记录（就是先执行 (5) 再执行循环IDs执行 (4,ID)) |



##### 示例代码

```python
class Book(models.Model): #书籍
...
    #出版商
    publisher_id = fields.Many2one(
            'res.partner', # 关联模型
            string='Publisher')
	#作者
    author_ids = fields.Many2many(
            'res.partner', # 关联模型
            string='Author')

```

```python
class Partner(models.Model):	#联系人模型
...
    _inherit = 'res.partner'
    #出版过的书籍
    published_book_ids = fields.One2many(
        'library.book', # 关联模型
        'publisher_id', # 关联模型中所指向的字段
        string='Published Books')
        
	 #作者的书籍
	book_ids = fields.Many2many(
    'library.book', 
    string='Authored Books')
```

```xml
<field name="users" eval="[(6,0,[ref('base.user_root')])]"/>
```

