##### 计算字段，提供由函数计算出值的属性。

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| compute      | 计算字段的方法的名称                                         |
| inverse      | 反转字段的方法，并写入（可选）                               |
| search       | 在字段上实现搜索的方法的名称（可选）                         |
| store        | 字段是否存储在数据库中（布尔值，默认情况下在计算字段上为False） |
| compute_sudo | 是否应将该字段重新计算为超级用户以绕过访问权限（布尔值，默认为False） |
| related      | 通过关联模型的字段可在模型中直接可用，并且可通过点号标记法直接访问 |



##### 计算字段(compute)：字段中可使用根据函数自动计算所得的类型

计算字段的声明方式与常规字段是一样的,只是使用了**compute**参数,参数被赋值为一个函数的名称

- 前端页面限制

  - 我们既需要保留**最后被收养时间**与**最后归还时间**两个字段的值,又不希望tree视图两个值都有数据显示,就只能修改xml了.

  - 在**views文件夹**下,打开**My_Cats_HomePage_view.xml**文件,修改tree视图:

    ```xml
    <tree>
         <field name="code"/>
         <field name="name"/>
         <field name="age"/>
         <field name="cat_type"/>
         <field name="price"/>
    
         <field name="borrowed"/>
         <!--添加attrs属性,当未被收养时隐藏最后被收养时间-->
         <field name="date_last_borrowed" attrs="{'invisible':[('borrowed','=',False)]}"/>
         <!--添加attrs属性,当已被收养时隐藏最后归还时间-->
         <field name="date_last_return" attrs="{'invisible':[('borrowed','=',True)]}"/>
         <field name="doing_date"/>
         <field name="description"/>
     </tree>
    ```

  - attrs基本属性:

    - readonly只读

    - required必填

    - invisible隐藏

    - attrs根据条件动态设置字段属性

      ```
      attrs=’{‘invisible’: [(‘is_ill’, ‘=’, True)], ‘required’: [(‘is_ill’, ‘=’, False)]}’
      ```

  - 与之前的数据库限制效果一致,不同的是,数据库所存储的值**并不会值空**,在pg库里,用sql语句查询时,数据依旧存在,他只是在**前端页面**被隐藏了而已:

  



##### 如何使用odoo compute属性实现自动计算字段

```python
class FandxProduct(models.Model):
    _name = "fandx.product"
 
    name = fields.Char("产品名称")
    nums = fields.Integer("数量")
    unit_price = fields.Float("产品单位价格")
```

现在有个需求，这是一个产品表，我们需要计算他的每一个产品的总价格（产品单位价格*数量），这时候就要用到我们的主角compute属性，下面看案例。

```python
class FandxProduct(models.Model):
    _name = "fandx.product"
 
    name = fields.Char("产品名称")
    nums = fields.Integer("数量")
    unit_price = fields.Float("产品单位价格")
    # 使用_compute_all_price
    all_price = fields.Float("产品总价格", compute="_compute_all_price")
 
    def _compute_all_price(self):
        # self取值默认是multi，所以需要循环拿到每一个record的值
        for record in self:
            # 计算每一个record的all_price的值进行赋值
            record.all_price = record.unit_price * record.nums
```

在字段中定义属性compute并指向计算方法，在数据创建的时候会自动计算这个字段的数据。

这样我们在XML中使用all_price就可以获取到产品的总价格，但是这里还有一个问题。

数据库中是没有进行持久存储的，那么数据数据量一大，每次渲染页面都要进行计算，这样是非常消耗服务器性能的，所以我们就要将计算的字段给存储起来。



##### 如何存储odoo compute计算字段的值

方法很简单，只需要在定义的field中加上store字段，这样就会把计算到的结果给存储到数据库中。

```python
class FandxProduct(models.Model):
    _name = "fandx.product"
 
    name = fields.Char("产品名称")
    nums = fields.Integer("数量")
    unit_price = fields.Float("产品单位价格")
    # 使用_compute_all_price
    # 在字段中加上store = True实现数据的持久化
    all_price = fields.Float("产品总价格", compute="_compute_all_price", store=True)
 
    def _compute_all_price(self):
        # self取值默认是multi，所以需要循环拿到每一个record的值
        for record in self:
            # 计算每一个record的all_price的值进行赋值
            record.all_price = record.unit_price * record.nums
```

这样我们在数据库中就有了all_price的字段来记录产品总价格。

但是现在又出现一个问题，计算字段是计算出了我们的结果，但是如果nums改变，或者unit_price改变了，计算字段并不会改变怎么办！



##### compute配合使用depends监听数据变化

```python
class FandxProduct(models.Model):
    _name = "fandx.product"
 
    name = fields.Char("产品名称")
    nums = fields.Integer("数量")
    unit_price = fields.Float("产品单位价格")
    # 使用_compute_all_price
    # 在字段中加上store = True实现数据的持久化
    all_price = fields.Float("产品总价格", compute="_compute_all_price", store=True)
 
    # 将nums、unit_price字段进行监听，在数据变动的时候再次执行compute指向的方法进行重新赋值计算。
    @api.depends('nums', 'unit_price')
    def _compute_all_price(self):
        # self取值默认是multi，所以需要循环拿到每一个record的值
        for record in self:
            # 计算每一个record的all_price的值进行赋值
            record.all_price = record.unit_price * record.nums
```

到这里就基本实现了compute的所有经常使用的方法，下面一般会配合compute一起使用的属性`inverse`。



##### odoo中逆向计算inverse属性使用详解

上面讲解了compute方法是用来计算对应的数据字段的。

inverse方法其实就是compute的逆向方法，默认情况下xml中对应的compute计算字段是readonly的。

当我们加上inverse逆向计算的时候，那么就可以在XML中输入对应的值，然后系统会走inverse对应的方法。

```python
class FandxProduct(models.Model):
    _name = "fandx.product"
 
    name = fields.Char("产品名称")
    nums = fields.Integer("数量")
    unit_price = fields.Float("产品单位价格")
    # 使用_compute_all_price
    # 在字段中加上store = True实现数据的持久化
    all_price = fields.Float("产品总价格", compute="_compute_all_price", inverse='_set_unit_price', store=True)
 
    # 将nums、unit_price字段进行监听，在数据变动的时候再次执行compute指向的方法进行重新赋值计算。
    @api.depends('nums', 'unit_price')
    def _compute_all_price(self):
        # self取值默认是multi，所以需要循环拿到每一个record的值
        for record in self:
            # 计算每一个record的all_price的值进行赋值
            record.all_price = record.unit_price * record.nums
 
    def _set_unit_price(self):
        for record in self:
            if not all([record.nums, record.all_price]):
                continue
            
            # 当我们手动修改all_price的值的时候，我们就可以逆向去计算出unit_price的值，进行重新赋值。
            record.unit_price = record.all_price / record.nums
```



##### 总结

- odoo的compute可以实现我们对数据字段自动计算的需求。
- fields中加入store属性可以实现数据的持久化存储。
- compute计算字段在持久化存储之后不会在自动计算，需要我们配合depends来监听指定计算字段在数据改动的时候重新计算数据字段。
- inverse方法可以帮助我们解决compute计算字段readonly的问题，并在输入对应的字段进行逆向计算之前的字段。
- compute字段默认是store为False的所有search是无效的，还可以指定search的方式实现搜索。这里就不去细讲了，很简单也不常用。
- 还有compute_sudo属性可以设置字段在使用的时候是否以超级管理员的方式来进行计算，这里store=True的时候默认为True，否则默认为False，了解一下就可以了。



可选的store=True标记存储数据库中的字段。在这种情况下，执行计算后字段值会存储到数据库中，此后它们会像普通字段一样进行获取，而不是运行时重新计算。借助@api.depends装饰器，ORM会知道何时需要重新计算并更新这些存储值。你可以把它看作一个持久缓存。它还具有可将该字段作为搜索条件的好处，包括排序和分组的操作。如果在计算字段中使用store=True，则无需实再现search方法，因为字段已存储在数据库中，可以直接根据存储字段搜索、排序。

compute_sudo=True标记用于需要提权来执行计算的情况。这种情况可能是计算时需要使用终端用户无法访问的数据。

> 📝重要小记：Odoo v13中compute_sudo的默认值发生了改变。在Odoo v13之前，compute_sudo的值为False。但在v13中，compute_sudo的默认值基于store属性。如果store属性为True，则compute_sudo为True，否则为False。但是开发者可以在字段定义放置compute_sudo来显式地手动进行修改。
>
> 使用它时需要小心，因为它会跳过权限规则 ，包含多公司设置的按公司分隔的规则。确保反复确认在计算中所使用的域来避免相关的问题。

