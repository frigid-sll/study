Redis为什么这么快？
1、在内存中进行数据操作
2、有高效的数据结构来对数据进行操作

Redis存储的数据类型？
1、String
2、hash
3、list
4、set
5、sort set

Redis存储数据的底层数据结构？
1、简单动态字符串（String）
2、双向链表（列表）
3、压缩列表（列表、哈希、有序集合）
4、哈希表（哈希、集合）
5、跳表（有序集合）
6、整数数组（集合）

Redis如何存储key-value的？
1、使用哈希表进行存储
2、哈希表里有哈希桶
3、一个哈希桶里面存储key和value
4、一个哈希桶里面可能有多个key-value，也称为哈希冲突
	由于hash算法保证相同对象拥有相同散列值，不同对象尽量拥有不同散列值。所以不同对象可能拥有相同的散列值。
5、使用哈希链式来解决哈希冲突
6、使用rehash来解决过多的哈希冲突（两张哈希表）
7、哈希表1使用过多，另外一张未使用的哈希表2就开始创建空间（比哈希表1的空间大），然后将使用过多的哈希表1内容转移到扩大空间后的哈希表2中。最后释放哈希表1的空间
8、每次转移数据都是在处理了一个请求时进行转移的，不是一次性全部转移
9、哈希表1留作下次rehash扩容备用

rehash的作用？
1、增加哈希桶
2、让逐渐增多的entry元素能在更多的桶之间分散保存
3、减少单个桶中的元素数量
4、从而减少单个桶的冲突

整数数组和压缩列表在查找时间复杂度没有优势，Redis为什么还要使用？
1、内存使用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少
	Redis是内存数据库
2、数组对CPU高速缓存支持更好，当集合元素数据较少时，默认采用内存紧凑排序的方式存储。数据过多转为哈希和跳表

为什么单线程的Redis会那么快？
1、基于内存操作
2、定制化的数据结构，大部分命令的时间复杂度是O（1）
3、单线程可以避免线程上下文切换带来的性能损耗
4、单线程程序不存在临界资源，不会出现锁以及并发竞争
5、采用了IO多路复用技术，可以高效的处理客户端的请求
6、但Redis其他功能，比如持久化、异步删除、集群同步等是由其他线程完成的
7、严格地说Redis不是单线程，只有网络IO处理和键值数据读写是单线程

AOF日志三种写回机制
a、no：由操作系统决定什么时候写回磁盘。高性能低安全。宕机后数据大量缺失
b、everysec：每秒写回，每个命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒将缓冲区的内容写入磁盘
c、always：同步写回。每个命令执行完，立马同步地将日志写回磁盘

AOF重写日志
1、由后台子进程bgrewriteaof来完成的，避免了阻塞主线程
2、重写是根据键值对当前的最新状态，为它生成对应的写入命令
3、写时复制原理，子进程拷贝的是主进程的页表，即虚实映射关系，不占有空间。当有新数据写入的时候主进程和子进程才会内存分离。
	a、这个拷贝过程会消耗大量的CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小
	b、实例越大，内存页表越大，fork阻塞时间越久
4、如果再有写操作，Redis会把这个操作写到它的缓冲区，即主进程和子进程都会申请新空间
5、如果操作系统打开了内存大页机制（Huge Page，页面大小为2M），那么父进程申请内存时（有新数据写入）阻塞的概率会大大提高。内存分配是以页为单位的。默认4k
6、AOF重写新创建了一个AOF文件，当重写完毕后后替代之前旧的文件

AOF重写也有一个重写日志，为什么不共享使用AOF日志？
1、父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能
2、如果AOF重写失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用

Redis如何来生成RDB文件？
1、save：在主线程中执行，会导致阻塞
2、bgsave：创建一个子线程，专门用于写入RDB文件。避免了主线程的阻塞，这也是Redis RDB文件生成的默认配置
	bgsave子进程是由主线程fork生成的，可以共享主线程的所有内存数据
	如果在备份途中有新的写操作，被操作的数据就会被复制一份，生成该数据的副本
	主线程在这个数据副本上进行修改。同时bgsave子进程可以继续把原来的数据写入RDB文件

Redis有哪几种快照备份？
1、全量快照
	a、频繁将全量数据写入磁盘，会给磁盘很大压力，多个快照竞争有限的磁盘宽带，前一个快照还没做完，后一个又开始做了，容易造成恶性循环
	b、bgsavce子进程需要通过fork操作从主线程创建出来。虽然子进程在创建后不会再阻塞主线程，但是，fork这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长
	c、如果频繁fork出bgsave子进程，就会频繁阻塞主线程了（在Redis中如果有一个bgsave在运行，就不会再启动第二个bgsave子进程）
2、增量快照
	a、做了一次全量快照后，后续的快照只对修改的数据进行快照记录
	b、但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，会带来额外的空间开销问题，对于内存资源宝贵的Redis来说有些得不偿失

综上：虽然和AOF相比，快照恢复速度快，但是快照的频率不好把握。如果频率太低，两次快照之间一旦宕机，就可能有较多数据丢失。如果频率太高，又会产生额外的开销

3、混合使用AOF日志和内存快照
	a、内存快照以一定的频率执行，在两次快照之间，shiyongAOF日志记录这期间的所有命令操作	
	b、快照不用很频繁的执行，避免了fork对主线程的影响
	c、AOF日志也只记录两次快照间的操作，不会出现文件过大的情况，也就避免了重写的开销

Redis高可靠性：
1、数据尽量丢失：AOF日志和RDB快照
2、服务尽量不中断：主从库模式

读操作：主从库都可以接收
写操作：首先到主库执行，然后主库将写操作同步给从库

主从库之间如何进行第一次同步：
1、建立连接，协商同步
	a、相互之间可以通过replicaof命令形成主库和从库之间的关系（replicaof 主库ip 端口）
	b、从库给主库发送psync命令，表示要进行数据同步，主库根据这个命令的参数来启动复制
	c、psync命令包含了主库的runID和复制进度offset两个参数
		runID：每个Redis实例启动时都会自动生成一个随机ID，用来唯一标记这个实例
		当从库和主库第一次复制时，因为不知道主库的runID，所以将runID设为“？”
		offset此时设为-1，表示第一次复制
2、主库同步数据给从库
	a、主库收到psync命令后，会用FULLRESYNC响应命令带上两个参数：主库runID和主库目前的复制进度offset。从库收到响应后，会记录下这两个参数
	FULLRESYNC响应表示第一次复制采用的是全量复制
	b、主库执行bgsave命令，生成RDB文件，接着发送给从库。
	c、主库将所有数据同步给从库，从库收到数据后，会先清空当前数据库，然后在本地完成数据加载，这个过程依赖于内存快照生成的RDB文件
3、主库发送新写命令给从库
	a、主库将数据同步给从库过程中，主库不会被阻塞，仍然可以正常接收请求。
	b、为了保证主从库的数据一致性，主库会在内存中用专门的replication buffeer，记录RDB文件生成后收到的所有写操作
	c、当主库完成RDB文件发送后，就会把此时replication buffer中的修改操作发给从库，从库重新执行操作。这样一来，主从库就实现同步了
4、一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆陆续续收到的命令操作在同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销
5、基于长连接的命令传播存在风险，最常见的就是网络断连或阻塞。如果网络断连，主从库之间就无法进行命令传播了，从库的数据就没办法保持和主库一致了，客户端就可能从从库读到旧数据

主从库间网络断了怎么办？
1、主从库会采用增量复制的方式继续同步（只会把主从库网络断连期间主库收到的命令同步给从库）
2、主从库断连后，主库会把新收到的写操作命令写入repl_backlog_buffer这个缓冲区
3、repl_backlog_buffer是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置
4、刚开始主库和从库的写读位置在一起，随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是masert_repl_offset。主库接收的新写操作越多，这个值就越大
5、从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。
6、主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。
7、因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。
8、我们要想办法避免这一情况，一般而言，我们可以调整 repl_backlog_size 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 repl_backlog_size = 缓冲空间大小 * 2，这也就是 repl_backlog_size 的最终值。


主从复制带来的影响：
1、一次全量复制中，对于主库来说，需要两个耗时操作
	a、生成RDB文件
	b、传输RDB文件
2、如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于fork子进程生成RDB文件。fork这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢
3、传输RDB文件也会占用主库的网络宽带，会给主库的资源使用带来压力

解决主从复制带给主库的压力：主从及联模式（主-从-从模式）
1、我们可以通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以及联的方式分散到从库上
2、在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置比较高的从库），用于次联其他的从库。
3、我们可以在选择一些从库（例如三分之一的从库），在这些库上执行replicaof 所选从库的IP 6379
4、这样一来，这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和次联的从库进行写操作同步就行了，这就可以减轻主库上的压力


全量复制虽然耗时，但对于从库来说，如果是第一次同步，全量复制是无法避免的，有哪些好建议呢？
1、一个Redis实例的数据库不要太大，一个实例大小在几GB级别比较合适
	这样可以减少RDB文件生成、传输和重新加载大开销
2、为了避免多个从库同时和主库进行全量复制，给主库带来过大的同步压力，可以采用“主从及联模式”

主从全量同步使用RDB而不使用AOF的原因：
1、RDB文件内容是经过压缩的二进制数据，不同数据类型数据做了针对性优化，文件很小
2、AOF文件记录的是每一次写操作的命令，写操作越多文件越大，其中还包括很多对同一个key的多次冗余操作
3、传输RDB文件可以尽量降低对主库机器网络宽带的消耗，从库在加载RDB时
	a、文件小、读取整个文件的速度很快
	b、RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度非常快
	c、AOF需要依次重放每个命令，过程会经历冗长的处理逻辑，恢复速度很慢
4、使用RDB进行主从全量同步的成本最低，如果要使用AOF做全量同步，必须打开AOF功能。打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能
5、RDB只有在需要定时备份和主从全量同步数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景下其实是不需要开启AOF的

replication buffer 和 repl_backlog_buffer 的区别
1、repl_backlog_buffer
	a、它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免了全量同步带来的性能开销
	b、如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量同步
	c、所以repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量同步的概率
	d、而在repl_backlog_buffer中找到主从差异的数据后，如何发给从库呢？这就用到了replication buffer
2、replication buffer
	a、Redis和客户端通信也好，和从库通信也好，Redis都需要分配一个内存buffer进行数据交互
	b、客户端是一个client，从库也是一个client。我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的
	c、Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互
	d、所以在主从增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer

既然有这个内存buffer存在，那么这个buffer有没有限制呢？
1、如果主从在传播命令时，因为某些原因从库处理得非常慢，那么从库上的这个buffer就会持续增长，消耗大量的内存资源，甚至OOM
2、所以Redis提供了client-output-buffer-limit参数限制了这个buffer的大小，如果超过限制，主库会强行断开client的连接
3、也就是说从库处理慢导致主库内存buffer的积压达到线之后，主库会强制断开从库的连接，此时主从复制会断开
4、中断后如果从库再次发起复制请求，那么此时可能导致恶性循环，引发复制风暴