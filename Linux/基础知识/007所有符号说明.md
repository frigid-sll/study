##### 系统符号

- 基础符号
  - `$`
    - 取出变量中的内容
    - 取出指定列的信息（awk）
    
      ```
      awk '{print $3}' /old.txt
      取出第三列的信息 
      ```
    - 表示用户命令提示符号
    - 表示一行的结尾
    
  - `!`
    
    - 表示取反或者排除
    - 命令行中表示取出最近命令
    - 用于表示强制操作处理
      - vim底行模式强制保存退出：`!wq`
    
  - `|`
    
    - 前一个命令执行结果交给后面命令处理
    - xargs配合使用：将信息进行分组显示
  
- 引号符号系列
  
  - `''`：sed和awk要使用单引号
  
    - 所见即所得
  
  - `""`
  
    - 对特殊信息会做解析
  
  - ``或$()：
  
    - 先执行里面的内容然后交给前面的命令，并且执行的结果如果是多行交给前面的命令变成了一行
  
  - 没有引号：
  
    - 和双引号功能类似
    - 但是可以直接识别通配符信息
  
    ```
    echo {00..5}.txt
    输出5个txt
    
    echo "{00..5}.txt"
    输出原样
    ```
  
- 定向符号系列

  - `>`：标准输出重定向符号

    - `2>`：错误输出重定向符号（只输出错误的）

  - `>>`：标准输出追加重定向符号

    - `2>>`：错误输出追加重定向符号

  - `<`：标准输入重定向符号

    ```
    tr < xargs <
    ```
  
  
    - `<<`：标准输入追加重定向符号
  
      ```
      cat >> /old.txt <<EOF
      xxx
      xxx
      EOF
      ```
  
  
  
    - 如何将正确和错误的信息都可以放进去(都是追加)
  
      ```
      echo old >> /var/1.log 2>> /var/1.log
      
      或
      echo old &>> /var/1.log
      
      或
      echo old >> /var/1.log 2>&1
      ```
  


- 路径信息系列

  - `../`：上一级目录
  - `./`：当前路径
  - `~`：返回到家目录
  - `-`：两个目录之间进行快速切换
- 逻辑符号

  - `&&`：与逻辑符号，前一个命令执行成功了才执行后面的命令
  - `||`：
    - 如果前面命令执行失败就执行后面的命令。
    - 如果前面命令执行成功就不执行后面的命令
    
  - `;`：不管前面执行是否成功都执行后面的命令（所有命令都执行）
  
  - `&&\`：可以将要执行的命令重新一行开始写
  



##### 通配符号：根据文件名称进行匹配

- `*`：模糊匹配所有内容
  - 在grep命令里使用的是正则符号：匹配前一个字符出现了0次或多次


- `{}`：

  - 生成序列信息（生成一行序列）

    ```
    echo {1..10}
    echo {01..10}
    echo {a..z}
    ```

  - 生成连续序列

    ```
    echo {1..10..2}
    1 3 5 7 9
    ```

  - 生成不连续序列

    ```
    echo {www,bbs,ccc}
    www bbs ccc
    ```

  - 生成组合序列

    ```
    echo {a..c}{01..03}
    a01 a02 a03 b01 b02 b03 c01 c02 c03
    
    echo A{01..03}
    A01 A02 A03
    ```

  - 快速备份文件数据

    ```
    echo old.txt{,.bak}
    old.txt old.txt.bak
    
    cp old.txt{,.bak}等价于cp old.txt old.txt.bak
    ```

  - 快速还原

    ```
    mv /old/1.txt{.bak,}等价于mv /old/1.txt.bak /old/1.txt
    ```

    


##### 正则符号：进行内容进行匹配

- 用处

  - 利用正则符号匹配文件内容信息

  - 正则符号经常出现在各种开发与研制

  - 正则符号经常被三剑客命令使用
- 分类
  - 基础正则符号：base
  - 扩展正则符号：extended



##### 基础符号

- `^`：匹配以什么开头的

  ```
  匹配当前路径下的目录
  ll | grep "^d"
  ```

- `$`：以什么结尾的信息

  ```
  匹配以/结尾的
  ll -F | grep "/$"
  
  -F 目录后面有一个/
  ```

- 不匹配空行

  ```
  grep -v "^$"
  ^$：匹配空行
  -v：取反
  ```

- `.`：匹配任意一个字符且只有一个字符

  ```
  grep -o '.' 1.txt
  
  -o：显示匹配过程
  发现每次匹配的都是一个字符一个字符匹配且如果行为空的话不匹配。会对文件所有内容都进行匹配
  ```
  
- `*`：匹配前一个字符出现了0次或多次

  ```
  grep -o '01*' 1.txt
  
  会对文件所有内容都进行匹配
  先匹配0 然后匹配1
  ```

- `.*`：匹配任意所有信息

  ```
  #这匹配的是以mm开头mm结尾中间没内容的行。就是一行的内容为mm
  grep "^mm$" 1.txt
  
  #这匹配的是以mm开头，mm结尾但中间有内容
  grep "^mm.*mm$" 1.txt
  ```

- 贪婪匹配问题：指定具体的匹配信息

- 转义符号：`\`

  ```
  grep "\.$" 1.txt
  
  匹配以.结尾的行
  ```

  - 将有特殊意义的符号，转义成普通信息进行识别

  - 将没有意义的信息转为有特殊意义的信息

    ```
    \n：换行符号
    \t：制表符号
    ```


- 括号符号：`[]`：匹配多个信息。**括号里面的的每个字符都是独立的**

  ```
  grep "oldb[oe]y" 1.txt
  匹配oldboy和oldbey的信息。
  
  grep "^[a-Z]" 1.txt
  ```

  - 括号中的排除：`^`

    ```
    grep "^[^a-Z]" 1.txt
    
    匹配不以a-Z开头的行，不包含空行
    ```



##### 扩展符号：默认grep、sed不能直接识别。grep需要加-E，sed需要加-r

- `+`：匹配前一个字符一次或多次

  ```
  grep -E "0+" 1.txt
  ```

- `|`：并且符号，用于匹配多个信息

  ```
  grep -E "oldboy|blog" 1.txt
  匹配oldboy或blog信息的数据
  ```

- `()`： 指定信息进行整体匹配；进行后项引用前项使用

  - 批量创建用户
  
    ```
    echo oldboy{01..10} | xargs -n1 | sed -r 's#(.*)#useradd \1#g' | bash
    
    ehco oldboy{01..10}:一行输出oldboy01到oldboy10
    |xargs -1：将每一块变成一列一列
    |sed -r 's#(.*)#useradd \1#g':
    -r：识别高级正则符号
    s：substitute替换
    #要修改的内容#修改后的内容#：修改规则
    (.*)：一行的所有内容作为一个整体，也就是前项
    useradd \1：
    useradd：创建用户命令
    \1：调用前项，也就是(.*)匹配的内容
    |bash：执行命令 useradd .*
    ```
  
  - 批量创建并且修改密码
  
    ```
    seq -w 10 | sed -r 's#(.*)#useradd oldboy\1#g';echo 123456 | passwd --stdin oldboy\1 | bash
    
    seq -w 10:
    01
    02
    ...
    10
    
    |sed -r 's#(.*)#useradd oldboy\1#g':
    useradd oldboy01
    useradd oldboy02
    ...
    useradd oldboy10
    
    #要修改的内容#修改后的内容#：修改规则
    (.*)：一行的所有内容作为一个整体，也就是前项
    useradd \1：
    useradd：创建用户命令
    \1：调用前项，也就是(.*)匹配的内容
    ;:不管前面命令是否执行成功都执行后面的命令
    echo 123456 | pwsswd --stdin oldboy01:免交互设置密码
    |bash：执行命令 useradd .*
    ```
  
- `{}`：指定字符连续匹配的次数

  ```
  x{n,m}：x字符至少出现n次，最多匹配m次
  grep -E "0{2,3}" 1.txt
  如果有连续的3个0，就会只匹配三个0
  如果有连续的5个0，就会先匹配3个在匹配2个。五个都会匹配出来
  
  x{n,}：最少匹配n次，最多不限制
  
  x{n}：指定匹配n次
  ```

- `?`：匹配前一个字符出现0次或1次

  ```
  ifconfig | grep "([0-9]+\.?){4}" -0
  [0-9]出现了多次 .出现0次或一次。 这个整体匹配4次
  ```

  

